<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.ohtoai.fun/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.ohtoai.fun/" rel="alternate" type="text/html" /><updated>2023-11-11T15:26:21+00:00</updated><id>https://blog.ohtoai.fun/feed.xml</id><title type="html">RK’s blog</title><subtitle>不知名211大三在读
</subtitle><author><name>phrk</name><email>phrknfish@outlook.com</email></author><entry><title type="html">《上个世纪的学校》 书摘</title><link href="https://blog.ohtoai.fun/2023/10/23/%E4%B8%8A%E4%B8%AA%E4%B8%96%E7%BA%AA%E7%9A%84%E5%AD%A6%E6%A0%A1.html" rel="alternate" type="text/html" title="《上个世纪的学校》 书摘" /><published>2023-10-23T14:02:57+00:00</published><updated>2023-10-23T14:02:57+00:00</updated><id>https://blog.ohtoai.fun/2023/10/23/%E4%B8%8A%E4%B8%AA%E4%B8%96%E7%BA%AA%E7%9A%84%E5%AD%A6%E6%A0%A1</id><content type="html" xml:base="https://blog.ohtoai.fun/2023/10/23/%E4%B8%8A%E4%B8%AA%E4%B8%96%E7%BA%AA%E7%9A%84%E5%AD%A6%E6%A0%A1.html"><![CDATA[<p>书源 《昨日的世界》 茨威格 ,  数百年前的「现代」「教育」，「军事化」的教育</p>

<h2 id="pt1-填鸭式流水线化的教育">Pt.1 填鸭式、流水线化的教育</h2>

<blockquote>
  <p>然而，在那开明的自由主义时代，只有所谓高等学府的教育，即进入大学，才完全有真正的价值。因此，每个上流家庭都追慕在自己的儿子中至少有一个在名字前冠有博士学衔。但这条通往大学的道路却是相当漫长和一点都不令人感到愉快。因为在此之前必须坐在硬板凳上念完五年国民小学和八年中学，每天要坐五至六小时，课余时间则完全被作业占满，而且还要接受除了学校课程以外的常规教育，即，除了学习古典的希腊语和拉丁语以外还要学习活的语言—法语、英语、意大利语，也就是说，除了几何、物理和学校规定的其他课程以外还要学习五种语言。学习负担重得不能再重，几乎没有进行体育锻炼和散步的时间，更谈不上消遣和娱乐。</p>
</blockquote>

<p>大学？或者说，名校真的有所谓的用处吗？超极限的压榨式学习，这是我的写照。</p>

<hr />

<blockquote>
  <p>学校对我们来说，意味着强迫、荒漠、无聊，是一处不得不在那里死记硬背那些仔细划分好了的毫无知识价值的科学的场所。我们从那些经院式或者装成经院式的内容中感觉到，它们和现实，和我们个人兴趣毫无关系。<strong>那是一种无精打采、百无聊赖的学习，不是为生活而学习，而是为学习而学习，</strong>是旧教育强加于我们身上的学习。而唯一真正令人欢欣鼓舞的幸福时刻，就是我永远离开学校的那一天—我得为它感谢学校。</p>

  <p>这倒并不是我们奥地利的学校本身不好。恰恰相反，所谓教学计划是根据近一百年的经验认真制订的，倘若教学方法生动活泼，也确实能够奠定一个富有成效的相当广博的学习基础。但是正因为刻板的计划性和干巴巴的教条，使得我们的课死气沉沉和枯燥透顶。上课成了一种冷冰冰的学习器械，从来不依靠个人进行调节，而仅仅象一具标有良好、及格、不及格刻度的自动装置，以此来表示学生适应教学计划的要求达到了什么程度。</p>

  <p>然而，<strong>恰恰是这种索然无味、缺乏个性、对人漠不关心、兵营似的生活，无意之中使我们不胜痛苦。</strong>我们必须学习规定的课程，而且凡是学过的东西都要考试。在八年之中没有一个教师问过我们一次，我们自己希望学些什么，更没有鼓励的意思，而这正是每个年轻人所悄悄盼望的。</p>
</blockquote>

<hr />

<blockquote>
  <p>不过，那种令人沮丧的学校生活也不能怪我们的老师。对于他们，既不能说好，也不能说坏。 <strong>他们既不是暴君，也不是乐于助人的伙伴，而是一些可怜虫。他们是条条框框的奴隶，束缚于官署规定的教学计划，他们也象我们一样必须完成自己的课程。</strong> 我们清楚地感觉到：当中午学校的钟声一响，他们也像我们一样获得了自由，欢愉之情和我们没有什么两样。他们不爱我们，也不恨我们，之所以如此，是因为他们根本不了解我们。过了好几年，他们也还只知道我们中间极少数几个人的名字。而且，就当时的教学方法而言，他们除了批改出学生在上次作业中有多少错误以外，再也没有什么要关心的了。他们高高地坐在讲坛上，我们坐在台底下；他们提问，我们回答，除此以外，我们之前没有任何联系。因为在师生之间，在讲坛和课椅之间，在可以看得见的高高在上和可以看得见的眼皮底下之间，隔着那堵看不见的权威之墙，它阻碍着任何的接触。一个教员理应把学生当作一个希望对他自己的特殊个性有深入了解的人来看待，或者甚至象今天司空见惯的那样，有责任为学生写出报告，即把他观察到的学生的情况写出来，但在当时，这些是大大超出他的权限和能力的。更何况，私人谈话还会降低他的权威性，因为这样谈话很容易使我们这些学生和身为前辈的他平起平坐。我觉得，最能说明我们和教员之间在思想感情上毫不沾边的一点是，我早已把他们所有人的名字和面貌忘得一干二净。在我的记忆中，只清清楚楚保留着那座讲坛和那本我们始终想偷看一下的班级记事簿的形象，因为里面记着我们的分数。我今天还记得那本教员们主要用来评分的小小的红笔记本，记得那支用来记分的黑短铅笔，记得自己那些被教员用红墨水批改过的练习簿，但是我怎么也记不得他们之中任何一个人的脸—也许因为我们站在他们面前的时候总是低着头或者从不认真地看过他们一眼。</p>

  <p>对学校的这种反感并不是一种个人的成见；我记不得在我的同学中有谁对这种一成不变的生活不反感的，它压抑和磨平了我们最好的志趣。不过，只是到了很久以后我才意识到，对我们它少年的教育采用这样一种冷漠无情的方法，并不是出于国家主管部门的疏忽，而是包藏着一种经过深思熟虑、秘而不宣的既定意图。我们面临的世界，或者说，主宰我们命运的世界，它把自己的一切想法都集中在追求一个太平盛肚的偶像上，它对青年一代是不喜欢的，说得更透彻一点，它对青年一代始终抱着怀疑。<strong>对自己有条不紊的进步和秩序感到沾沾自喜的市民社会宣称，在一切生活领域中从容不迫和中庸节制是人的唯一能见成效的品德，所以，任何要把我们引导向前的急躁都应该避免。</strong>奥地利是由一位自发苍苍的皇帝统治着和由年迈的大臣们管理着的一个古老的国家，是一个没有雄心壮志的国家，它只希望能防止各种激烈的变革，从而保住自己在欧洲范围内的安然无恙的地位。而年轻人的天性，就是要不断进行迅速、激烈的变革。因此他们也就成了一种令人忧虑的因素，这种因素必须尽可能长时间地被排斥在外或者压制下去。所以国家根本没有打算要使我们学生时代的生活过得愉快。我们应该通过耐心的等待才能得到任何形式的升迁。由于这种不断的往后推移，因此年龄也就像今天一样完全要用另一种标准来衡量。那时候，一个十八岁的中学生就像一个孩子似地被对待，如果当场抓住他在吸烟，就要受到惩罚，如果他因要解手而想要离开课椅，就得毕恭毕敬地先举手。 <strong>不过话又要说回来，在那个时候，纵然是一个三十岁的男子汉，也还会被看作是一只羽毛未丰的小鸟呢，而且即便到了四十岁，也还被认为不足以胜任一个负责的职位。</strong></p>
</blockquote>

<p>螺丝钉，似乎没有人能逃出。</p>

<hr />

<h2 id="pt2-权威教育">Pt.2 权威「教育」</h2>

<blockquote>
  <p>唯有了解这样一种特殊的观念，才会明白，国家就是要充分利用学校作为维护自己权威的工具。<strong>学校首先就得教育我们把现存的一切尊为完美无缺的，教师的看法是万无一失的，父亲的话是不可反驳的，国家的一切设施都是绝对有效和与世永存的。</strong> <strong><em>这种教育的第二个基本原则，就是不应该让青年人太舒服。这一原则也在家庭中贯彻。</em></strong>在给予青年人某些权利之前，他们首先应该懂得自己要尽义务，而且主要是尽完全服从的义务。从一开始就应该让我们牢牢记住：我们在一生中尚未有任何的贡献，没有丝毫的经验，唯有对给予我们的一切永铭感激之情，而没有资格提什么问题或者什么要求。在我那个时代，从孩提时候起就对人采用吓唬的蠢办法。女仆和愚蠢的母亲们在孩子三四岁的时候就吓唬他们，说什么如果他们再闹的话，就去叫警察。</p>
</blockquote>

<hr />

<h2 id="pt3-脆弱">Pt3. 脆弱</h2>

<blockquote>
  <p>在此之前，被我们错误地称为普遍的选举权，实际上只是赋予交纳了一定税款的有产阶级。然而，从这个阶级中挑选出来的律师们以及农场主们却真诚地相信，自己在国会里是民众的代表和发言人。他们为自己是受过教育的人，甚至大部分是受过高等学府教育的人而无比自傲。</p>

  <p>他们讲究尊严、体面、高雅的谈吐，因此国会开会时就像一家高级俱乐部的晚间讨论会。这些资产阶级民主主义者出于自己对自由主义的信仰，真诚地相信通过宽容和理性必然会使世界进步，他们主张用小小的妥协和逐渐的改善，来促进全体子民们的福利，并认为这是最好的办法。 <strong>但他们完全忘记了自己仅仅代表大城市里五万或十万生活富裕的人，而并不代表全州儿十万和几百万人。</strong> 在此期间，机器生产也起到了作用，它把以往分散的工人集中到工业中来。在一位俊杰—维克托阿德勒博士的领导下，奥地利成立了一个社会主义政党，旨在实现无产阶级的各种要求；无产阶级要求有真正普遍和人人平等的选举权。可是，这种选举权刚一实行，或者更确切一点说，刚一被迫实行，人们就立刻发现，备受推崇的自由主义是何等的脆弱。随着自由主义的消失，公共政治生活中的和睦相处也就不复存在。现在处处是激烈的利害冲突。斗争开始了。</p>
</blockquote>

<blockquote>
  <p>大商店和大规模生产，使小资产阶级和手工业企业的师傅们面临着破产。卡尔卢埃格尔博士—一位受人欢迎、机灵能干的领袖人物，利用这种不满和忧虑，提出了必须帮助小人物的口号，他把全体小市民和恼怒的小资产阶级吸引到自己身边； <strong>因为他们对自己将从有产者降为无产者的恐惧远远超过对有钱人物的嫉妒。</strong> 正是这个优心仲仲的社会阶层，后来成为希特勒周围的第一批广大群众。从某种意义上讲，卡尔卢埃格尔是希特勒的榜样，是他教会了希特勒随心所欲地利用反犹太主义的口号。这一口号为不满的小资产阶级树立了一个可见的敌人，同时却又悄悄转移了他们对大地主和封建华贵的仇恨。</p>
</blockquote>

<blockquote>
  <p>然而我们这些年轻人却完全沉浸在自己的文学的志趣之中，对祖国的这些危险变化很少注意，在我们眼里只有书籍和绘画。我们对政治和社会问题丝毫不感兴趣。那种刺耳的不断争吵对我们的生活有什么意义呢当全城的人为了选举而兴奋激动时，我们却向图书馆走去，当群众举行暴动时，我们正在写作和讨论诗文。我们没有看到墙上着火的信号，而是象古时的伯沙撒国王一样，无忧无虑地品尝着各种珍贵的艺术佳肴，没有警惕地朝前看一眼，一直到几十年以后，当屋顶和墙垣倒塌到我们头顶上时，我们才认识到，墙基早已挖空，认识到：随着新世纪的开始，个人自由也已在欧洲开始没落。</p>
</blockquote>

<p>当年轻人无法再获得「被承诺」所获得的东西，当几代人积累的财富被窃取时，我们究竟该如何走下去。</p>]]></content><author><name>phrk</name><email>phrknfish@outlook.com</email></author><category term="散文" /><summary type="html"><![CDATA[书源 《昨日的世界》 茨威格 , 数百年前的「现代」「教育」，「军事化」的教育 Pt.1 填鸭式、流水线化的教育 然而，在那开明的自由主义时代，只有所谓高等学府的教育，即进入大学，才完全有真正的价值。因此，每个上流家庭都追慕在自己的儿子中至少有一个在名字前冠有博士学衔。但这条通往大学的道路却是相当漫长和一点都不令人感到愉快。因为在此之前必须坐在硬板凳上念完五年国民小学和八年中学，每天要坐五至六小时，课余时间则完全被作业占满，而且还要接受除了学校课程以外的常规教育，即，除了学习古典的希腊语和拉丁语以外还要学习活的语言—法语、英语、意大利语，也就是说，除了几何、物理和学校规定的其他课程以外还要学习五种语言。学习负担重得不能再重，几乎没有进行体育锻炼和散步的时间，更谈不上消遣和娱乐。 大学？或者说，名校真的有所谓的用处吗？超极限的压榨式学习，这是我的写照。 学校对我们来说，意味着强迫、荒漠、无聊，是一处不得不在那里死记硬背那些仔细划分好了的毫无知识价值的科学的场所。我们从那些经院式或者装成经院式的内容中感觉到，它们和现实，和我们个人兴趣毫无关系。那是一种无精打采、百无聊赖的学习，不是为生活而学习，而是为学习而学习，是旧教育强加于我们身上的学习。而唯一真正令人欢欣鼓舞的幸福时刻，就是我永远离开学校的那一天—我得为它感谢学校。 这倒并不是我们奥地利的学校本身不好。恰恰相反，所谓教学计划是根据近一百年的经验认真制订的，倘若教学方法生动活泼，也确实能够奠定一个富有成效的相当广博的学习基础。但是正因为刻板的计划性和干巴巴的教条，使得我们的课死气沉沉和枯燥透顶。上课成了一种冷冰冰的学习器械，从来不依靠个人进行调节，而仅仅象一具标有良好、及格、不及格刻度的自动装置，以此来表示学生适应教学计划的要求达到了什么程度。 然而，恰恰是这种索然无味、缺乏个性、对人漠不关心、兵营似的生活，无意之中使我们不胜痛苦。我们必须学习规定的课程，而且凡是学过的东西都要考试。在八年之中没有一个教师问过我们一次，我们自己希望学些什么，更没有鼓励的意思，而这正是每个年轻人所悄悄盼望的。 不过，那种令人沮丧的学校生活也不能怪我们的老师。对于他们，既不能说好，也不能说坏。 他们既不是暴君，也不是乐于助人的伙伴，而是一些可怜虫。他们是条条框框的奴隶，束缚于官署规定的教学计划，他们也象我们一样必须完成自己的课程。 我们清楚地感觉到：当中午学校的钟声一响，他们也像我们一样获得了自由，欢愉之情和我们没有什么两样。他们不爱我们，也不恨我们，之所以如此，是因为他们根本不了解我们。过了好几年，他们也还只知道我们中间极少数几个人的名字。而且，就当时的教学方法而言，他们除了批改出学生在上次作业中有多少错误以外，再也没有什么要关心的了。他们高高地坐在讲坛上，我们坐在台底下；他们提问，我们回答，除此以外，我们之前没有任何联系。因为在师生之间，在讲坛和课椅之间，在可以看得见的高高在上和可以看得见的眼皮底下之间，隔着那堵看不见的权威之墙，它阻碍着任何的接触。一个教员理应把学生当作一个希望对他自己的特殊个性有深入了解的人来看待，或者甚至象今天司空见惯的那样，有责任为学生写出报告，即把他观察到的学生的情况写出来，但在当时，这些是大大超出他的权限和能力的。更何况，私人谈话还会降低他的权威性，因为这样谈话很容易使我们这些学生和身为前辈的他平起平坐。我觉得，最能说明我们和教员之间在思想感情上毫不沾边的一点是，我早已把他们所有人的名字和面貌忘得一干二净。在我的记忆中，只清清楚楚保留着那座讲坛和那本我们始终想偷看一下的班级记事簿的形象，因为里面记着我们的分数。我今天还记得那本教员们主要用来评分的小小的红笔记本，记得那支用来记分的黑短铅笔，记得自己那些被教员用红墨水批改过的练习簿，但是我怎么也记不得他们之中任何一个人的脸—也许因为我们站在他们面前的时候总是低着头或者从不认真地看过他们一眼。 对学校的这种反感并不是一种个人的成见；我记不得在我的同学中有谁对这种一成不变的生活不反感的，它压抑和磨平了我们最好的志趣。不过，只是到了很久以后我才意识到，对我们它少年的教育采用这样一种冷漠无情的方法，并不是出于国家主管部门的疏忽，而是包藏着一种经过深思熟虑、秘而不宣的既定意图。我们面临的世界，或者说，主宰我们命运的世界，它把自己的一切想法都集中在追求一个太平盛肚的偶像上，它对青年一代是不喜欢的，说得更透彻一点，它对青年一代始终抱着怀疑。对自己有条不紊的进步和秩序感到沾沾自喜的市民社会宣称，在一切生活领域中从容不迫和中庸节制是人的唯一能见成效的品德，所以，任何要把我们引导向前的急躁都应该避免。奥地利是由一位自发苍苍的皇帝统治着和由年迈的大臣们管理着的一个古老的国家，是一个没有雄心壮志的国家，它只希望能防止各种激烈的变革，从而保住自己在欧洲范围内的安然无恙的地位。而年轻人的天性，就是要不断进行迅速、激烈的变革。因此他们也就成了一种令人忧虑的因素，这种因素必须尽可能长时间地被排斥在外或者压制下去。所以国家根本没有打算要使我们学生时代的生活过得愉快。我们应该通过耐心的等待才能得到任何形式的升迁。由于这种不断的往后推移，因此年龄也就像今天一样完全要用另一种标准来衡量。那时候，一个十八岁的中学生就像一个孩子似地被对待，如果当场抓住他在吸烟，就要受到惩罚，如果他因要解手而想要离开课椅，就得毕恭毕敬地先举手。 不过话又要说回来，在那个时候，纵然是一个三十岁的男子汉，也还会被看作是一只羽毛未丰的小鸟呢，而且即便到了四十岁，也还被认为不足以胜任一个负责的职位。 螺丝钉，似乎没有人能逃出。 Pt.2 权威「教育」 唯有了解这样一种特殊的观念，才会明白，国家就是要充分利用学校作为维护自己权威的工具。学校首先就得教育我们把现存的一切尊为完美无缺的，教师的看法是万无一失的，父亲的话是不可反驳的，国家的一切设施都是绝对有效和与世永存的。 这种教育的第二个基本原则，就是不应该让青年人太舒服。这一原则也在家庭中贯彻。在给予青年人某些权利之前，他们首先应该懂得自己要尽义务，而且主要是尽完全服从的义务。从一开始就应该让我们牢牢记住：我们在一生中尚未有任何的贡献，没有丝毫的经验，唯有对给予我们的一切永铭感激之情，而没有资格提什么问题或者什么要求。在我那个时代，从孩提时候起就对人采用吓唬的蠢办法。女仆和愚蠢的母亲们在孩子三四岁的时候就吓唬他们，说什么如果他们再闹的话，就去叫警察。 Pt3. 脆弱 在此之前，被我们错误地称为普遍的选举权，实际上只是赋予交纳了一定税款的有产阶级。然而，从这个阶级中挑选出来的律师们以及农场主们却真诚地相信，自己在国会里是民众的代表和发言人。他们为自己是受过教育的人，甚至大部分是受过高等学府教育的人而无比自傲。 他们讲究尊严、体面、高雅的谈吐，因此国会开会时就像一家高级俱乐部的晚间讨论会。这些资产阶级民主主义者出于自己对自由主义的信仰，真诚地相信通过宽容和理性必然会使世界进步，他们主张用小小的妥协和逐渐的改善，来促进全体子民们的福利，并认为这是最好的办法。 但他们完全忘记了自己仅仅代表大城市里五万或十万生活富裕的人，而并不代表全州儿十万和几百万人。 在此期间，机器生产也起到了作用，它把以往分散的工人集中到工业中来。在一位俊杰—维克托阿德勒博士的领导下，奥地利成立了一个社会主义政党，旨在实现无产阶级的各种要求；无产阶级要求有真正普遍和人人平等的选举权。可是，这种选举权刚一实行，或者更确切一点说，刚一被迫实行，人们就立刻发现，备受推崇的自由主义是何等的脆弱。随着自由主义的消失，公共政治生活中的和睦相处也就不复存在。现在处处是激烈的利害冲突。斗争开始了。 大商店和大规模生产，使小资产阶级和手工业企业的师傅们面临着破产。卡尔卢埃格尔博士—一位受人欢迎、机灵能干的领袖人物，利用这种不满和忧虑，提出了必须帮助小人物的口号，他把全体小市民和恼怒的小资产阶级吸引到自己身边； 因为他们对自己将从有产者降为无产者的恐惧远远超过对有钱人物的嫉妒。 正是这个优心仲仲的社会阶层，后来成为希特勒周围的第一批广大群众。从某种意义上讲，卡尔卢埃格尔是希特勒的榜样，是他教会了希特勒随心所欲地利用反犹太主义的口号。这一口号为不满的小资产阶级树立了一个可见的敌人，同时却又悄悄转移了他们对大地主和封建华贵的仇恨。 然而我们这些年轻人却完全沉浸在自己的文学的志趣之中，对祖国的这些危险变化很少注意，在我们眼里只有书籍和绘画。我们对政治和社会问题丝毫不感兴趣。那种刺耳的不断争吵对我们的生活有什么意义呢当全城的人为了选举而兴奋激动时，我们却向图书馆走去，当群众举行暴动时，我们正在写作和讨论诗文。我们没有看到墙上着火的信号，而是象古时的伯沙撒国王一样，无忧无虑地品尝着各种珍贵的艺术佳肴，没有警惕地朝前看一眼，一直到几十年以后，当屋顶和墙垣倒塌到我们头顶上时，我们才认识到，墙基早已挖空，认识到：随着新世纪的开始，个人自由也已在欧洲开始没落。 当年轻人无法再获得「被承诺」所获得的东西，当几代人积累的财富被窃取时，我们究竟该如何走下去。]]></summary></entry><entry><title type="html">Lecture #06: Memory Management</title><link href="https://blog.ohtoai.fun/cmu15-445/2023/10/23/Lecture-6-Memory-Management.html" rel="alternate" type="text/html" title="Lecture #06: Memory Management" /><published>2023-10-23T03:10:55+00:00</published><updated>2023-10-30T12:58:31+00:00</updated><id>https://blog.ohtoai.fun/cmu15-445/2023/10/23/Lecture-6-Memory-Management</id><content type="html" xml:base="https://blog.ohtoai.fun/cmu15-445/2023/10/23/Lecture-6-Memory-Management.html"><![CDATA[<p><a href="/cmu15-445/2023/10/02/CMU-Project-Tracker.html" class="button button--outline-secondary button--pill"><i class="fa-solid fa-link"></i> Tracker</a></p>

<p>TODO: <a href="https://youtu.be/Y9H2HaRKOIw?list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;t=1141">https://youtu.be/Y9H2HaRKOIw?list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;t=1141</a></p>

<h2 id="1-introduction">1. Introduction</h2>

<p>如何存储：</p>

<ul>
  <li>我们的 pages 要存储在 disk 上的什么样的地方</li>
</ul>

<p>快速操作：</p>

<ul>
  <li>
    <p>对于 DBMS 来说，在进行操作数据之前需要将所有的的数据从 Disk 先转移到 Memory 中才可以进行操作。</p>

    <p><img src="https://imgur.com/Fb6bfcD.png" alt="" /></p>
  </li>
</ul>

<p><img src="https://imgur.com/x6oYq9T.png" alt="" /></p>

<hr />

<h2 id="2-locks-vs-latches">2. Locks vs. Latches</h2>

<p><img src="https://imgur.com/YG9cxAA.png" alt="" /></p>

<hr />

<h2 id="3-buffer-pool">3. Buffer Pool</h2>

<p>Memory 中存储的是一个个固定大小的 pages。</p>

<p>其中的每一个记录称之为 <em>frame</em></p>

<p>当我们需要一个 page 的时候，我们会立刻复制一个 frame。</p>

<p>Dirty pages 不会立刻写回。(Write-Back Cache)</p>

<p><img src="https://imgur.com/zYv4D0C.png" alt="" /></p>

<h3 id="buffer-pool-meta-data">Buffer Pool Meta-data</h3>

<p><img src="https://imgur.com/vRnMHx4.png" alt="" /></p>

<p><em>page table</em> 是用来跟踪哪些 pages 在 memory 中。</p>

<p>通常还有一些信息也会被保存在 page table 中</p>
<ul>
  <li>Dirty Flag</li>
  <li>Pin/Reference Counter</li>
</ul>

<p>Dirty Flag 用来表示这个页是否被写过。</p>

<p>Pin/Reference Counter 是用来固定 frame 来确保该页面不会被放回到 disk 中。</p>

<blockquote>
  <p><strong>page directory</strong> 是一个将 page id 映射到 page location 的一个映射。所有信息必须存放在 disk 上，以便 DBMS 可以找到</p>

  <p><strong>page table</strong> 是一个将 page id 映射到 buffer pool 中的帧上的映射。这是一个 in-memory 的数据结构不需要存储在 disk 上。</p>
</blockquote>

<h3 id="memory-allocation-policies">Memory Allocation Policies</h3>

<hr />

<h2 id="4-buffer-pool-optimizations">4. Buffer Pool Optimizations</h2>

<h3 id="multiple-buffer-pools">Multiple Buffer Pools</h3>

<h3 id="pre-fetching">Pre-fetching</h3>

<h3 id="scan-sharingsynchornized-scans">Scan Sharing(Synchornized Scans)</h3>

<h3 id="buffer-pool-bypass">Buffer Pool Bypass</h3>

<hr />

<h2 id="5-os-page-cache">5. OS Page Cache</h2>

<hr />

<h2 id="6-buffer-replacement-policies">6. Buffer Replacement Policies</h2>

<hr />]]></content><author><name>phrk</name><email>phrknfish@outlook.com</email></author><category term="CMU15-445" /><category term="数据库" /><category term="CMU15-445" /><summary type="html"><![CDATA[Tracker TODO: https://youtu.be/Y9H2HaRKOIw?list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;t=1141 1. Introduction 如何存储： 我们的 pages 要存储在 disk 上的什么样的地方 快速操作： 对于 DBMS 来说，在进行操作数据之前需要将所有的的数据从 Disk 先转移到 Memory 中才可以进行操作。 2. Locks vs. Latches 3. Buffer Pool Memory 中存储的是一个个固定大小的 pages。 其中的每一个记录称之为 frame 当我们需要一个 page 的时候，我们会立刻复制一个 frame。 Dirty pages 不会立刻写回。(Write-Back Cache) Buffer Pool Meta-data page table 是用来跟踪哪些 pages 在 memory 中。 通常还有一些信息也会被保存在 page table 中 Dirty Flag Pin/Reference Counter Dirty Flag 用来表示这个页是否被写过。 Pin/Reference Counter 是用来固定 frame 来确保该页面不会被放回到 disk 中。 page directory 是一个将 page id 映射到 page location 的一个映射。所有信息必须存放在 disk 上，以便 DBMS 可以找到 page table 是一个将 page id 映射到 buffer pool 中的帧上的映射。这是一个 in-memory 的数据结构不需要存储在 disk 上。 Memory Allocation Policies 4. Buffer Pool Optimizations Multiple Buffer Pools Pre-fetching Scan Sharing(Synchornized Scans) Buffer Pool Bypass 5. OS Page Cache 6. Buffer Replacement Policies]]></summary></entry><entry><title type="html">Lecture #05: Storage Models &amp;amp; Compression</title><link href="https://blog.ohtoai.fun/cmu15-445/2023/10/19/Lecture-5-Storage-Models-Compression.html" rel="alternate" type="text/html" title="Lecture #05: Storage Models &amp;amp; Compression" /><published>2023-10-19T13:42:33+00:00</published><updated>2023-10-23T05:58:13+00:00</updated><id>https://blog.ohtoai.fun/cmu15-445/2023/10/19/Lecture-5-Storage-Models-Compression</id><content type="html" xml:base="https://blog.ohtoai.fun/cmu15-445/2023/10/19/Lecture-5-Storage-Models-Compression.html"><![CDATA[<p><a href="/cmu15-445/2023/10/02/CMU-Project-Tracker.html" class="button button--outline-secondary button--pill"><i class="fa-solid fa-link"></i> Tracker</a></p>

<p><a href="https://15445.courses.cs.cmu.edu/fall2022/slides/05-storage3.pdf">refer to Slide</a></p>

<p><a href="https://15445.courses.cs.cmu.edu/fall2022/notes/05-storage3.pdf">refer to Note</a></p>

<pre><code class="language-mermaid">mindmap
root((Lecture 5))
  Workloads
    OLTP
    OLAP
    HTAP
  Storage Models
    N-Ary
    DSM
  Columnar Compression
    Run-Length Encoding
    Bit-Packing Encoding
    Delta Encoding
    Incremental Encoding
    Dictionary Encoding


</code></pre>

<h2 id="database-workloads">Database workloads</h2>

<h3 id="oltp">OLTP</h3>

<p>OLTP: On-Line Transaction Processing</p>

<p>每次快速的对一个小范围的数据进行读取、更新的操作。</p>

<p><img src="https://imgur.com/DJTL435.png" alt="OLTP" /></p>

<h3 id="olap">OLAP</h3>

<p>OLAP: On-Line Analytical Processing</p>

<p>OLAP 是用来支持复杂的分析操作，提供决策支持等</p>

<p><img src="https://imgur.com/mMuGQja.png" alt="OLAP" /></p>

<h3 id="htap">HTAP</h3>

<p>Hybrid Transaction + Analytical Processing</p>

<p>一种新的 workload ，将 OLTP 和 OOLAP 结合起来。</p>

<p><img src="https://s2.loli.net/2023/10/19/VGxJ9U7pNbZWYMe.png" alt="OLTP OLAP HTAP" /></p>

<hr />

<h2 id="stroage-models">Stroage Models</h2>

<h3 id="n-ary-storage-model-nsm">N-Ary Storage Model (NSM)</h3>

<p>在 <code class="language-plaintext highlighter-rouge">n-ary</code> 的存储模式中，DBMS 连续的存储所有的、包含所有 <code class="language-plaintext highlighter-rouge">arributes</code> 的 <code class="language-plaintext highlighter-rouge">tuple</code> 在一个单独的页面中。</p>

<p><img src="https://imgur.com/XiN0UkV.png" alt="n-ary-model" /></p>

<p>这对于 OLTP 来说是十分理想的。</p>

<p>Advantages:</p>
<ul>
  <li>插入，更新，删除非常快</li>
  <li>对于需要整个 <code class="language-plaintext highlighter-rouge">tuple</code> 的查询非常友好</li>
</ul>

<p>Disadvantages:</p>
<ul>
  <li>对于需要扫描整个表或者只需要一个属性的查询非常不好</li>
</ul>

<blockquote>
  <p><img src="https://imgur.com/zMMWPiu.png" alt="" /></p>
</blockquote>

<h3 id="decompositrion-storage-model-dsm">Decompositrion Storage Model (DSM)</h3>

<p>将所有 <code class="language-plaintext highlighter-rouge">tuples</code> 中的每个 <code class="language-plaintext highlighter-rouge">attribute</code> 单独分出来进行存储</p>

<blockquote>
  <p>也可以成为 “列存储 (column store)”</p>
</blockquote>

<p>对于只读的 OLAP 操作非常友好，尤其是那些只需要扫描部分 <code class="language-plaintext highlighter-rouge">attributes</code> 的操作来说。</p>

<p><img src="https://imgur.com/iONtz5L.png" alt="" /></p>

<p>Advantages:</p>
<ul>
  <li>减少 I/O 的浪费</li>
  <li>更好的进行查询以及将数据进行压缩</li>
</ul>

<p>Disadvantages:</p>
<ul>
  <li>对于单点修改查询更新这些操作比较慢。</li>
</ul>

<p>为了实现这种操作通常有两种操作方法。</p>
<ol>
  <li>为每个属性设置固定的字长，这样我们只需要得到 <code class="language-plaintext highlighter-rouge">offset</code> 就可以准确的查找到我们所需要的数据</li>
  <li>一个更为罕见的操作是，使用一个形如 <code class="language-plaintext highlighter-rouge">(id : pos)</code> 的 tuple 来存储值，表示第 <code class="language-plaintext highlighter-rouge">id</code> 的值存储在 <code class="language-plaintext highlighter-rouge">pos</code> 位置上。</li>
</ol>

<p><img src="https://imgur.com/IedfkNq.png" alt="" /></p>

<h2 id="database-compression">Database Compression</h2>

<p>I/O 是非常耗时的，通常是整个数据库的瓶颈，所以 DBMS 中广泛的采用压缩算法来提高 DBMS 的表现。</p>

<p>通常我们需要在 <strong>速度</strong> 和 <strong>压缩率</strong> 之间进行取舍。</p>

<h3 id="压缩颗粒度">压缩颗粒度</h3>
<ul>
  <li>Block Level</li>
  <li>Tuple Level 对整个 <code class="language-plaintext highlighter-rouge">tuple</code> 进行压缩 (NSM Only)</li>
  <li>Attribute Level</li>
  <li>Columnar Level</li>
</ul>

<h2 id="naive-compression">Naive Compression</h2>

<p>使用 “general-purpose” 的压缩算法通常也是一种解决办法。不过一旦使用着这种方法之后，DBMS 就不知道我们进行操作的数据是什么，直到解压完。</p>

<p>provided as input:<br />
→ LZO (1996), LZ4 (2011), Snappy (2011),
Oracle OZIP (2014), Zstd (2015)</p>

<p><img src="https://imgur.com/btfm5p9.png" alt="" /></p>

<p>为了提高速度，我们需要另外的压缩方法，即使是在压缩之后，我们也有办法获取其中的信息来加速。</p>

<p><img src="https://imgur.com/gmB5Ith.png" alt="" /></p>

<h2 id="columnar-compression">Columnar Compression</h2>

<h3 id="run-length-encodingrle">Run-Length Encoding(RLE)</h3>

<p>可以将一些连续出现在同一列上的值压缩成一个形如<code class="language-plaintext highlighter-rouge">(value : pos : num)</code> 的 <code class="language-plaintext highlighter-rouge">triplets</code>。</p>

<p>其中:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">value</code> 表示值</li>
  <li><code class="language-plaintext highlighter-rouge">pos</code> 表示该值的起始位置</li>
  <li><code class="language-plaintext highlighter-rouge">num</code> 表示该值重复的次数</li>
</ol>

<p><img src="https://imgur.com/4UVuuqG.png" alt="" /></p>

<blockquote>
  <p>不过该方法可能存在一些缺陷</p>

  <p><img src="https://imgur.com/odwQgWe.png" alt="" /></p>

  <p>经过转换后</p>

  <p><img src="https://imgur.com/WFfzLgP.png" alt="" /></p>
</blockquote>

<h3 id="bit-packing-encoding">Bit-Packing Encoding</h3>

<p>一些数据对我们来说是十分冗余的，我们可以通过 Bit-Packing 的方式来减少这些冗余。</p>

<p><img src="https://imgur.com/WLI2OFf.png" alt="" /></p>

<p>将 <code class="language-plaintext highlighter-rouge">int64</code> 转换为 <code class="language-plaintext highlighter-rouge">int8</code> 大大减少了需要的空间。</p>

<p>不过该方法存在一些缺陷，可能会存在部分信息有不符合 <code class="language-plaintext highlighter-rouge">int8</code> 的信息。</p>

<p>因此，我们需要如下的方式进行存储。</p>

<p><img src="https://imgur.com/K8lQr8R.png" alt="" /></p>

<p>不过该方法只能在额外存储信息较少的时候进行使用。</p>

<h3 id="bitmap-encoding">Bitmap Encoding</h3>

<p>当我们每个 <code class="language-plaintext highlighter-rouge">attribute</code> 较少的时候，我们可以采用 Bitmap 的方式进行存储。</p>

<p>例如，只存在 <code class="language-plaintext highlighter-rouge">F</code> 和 <code class="language-plaintext highlighter-rouge">M</code> 两种值的时候，我们就可以是由 <code class="language-plaintext highlighter-rouge">01</code> 来表示是或者不是。</p>

<p><img src="https://imgur.com/PNmEvKe.png" alt="" /></p>

<h3 id="delta-encoding">Delta Encoding</h3>

<p>在许多情况下，例如室温多少，我们的统计结果里可能存在较为密集的值在一定的范围内。</p>

<p>因此我们通过确定一个值后，往后的所有值都可以通过 <code class="language-plaintext highlighter-rouge">delta</code> 的形式存储</p>

<p><img src="https://imgur.com/XQe8W5Y.png" alt="" /></p>

<h3 id="incremental-encoding">Incremental Encoding</h3>

<p>我们通常也可以通过取 <strong>前缀 / 后缀</strong> 的形式来得到我们的最终结果。</p>

<p><img src="https://imgur.com/oM9zEKa.png" alt="" /></p>

<h3 id="dictionary-compression">Dictionary Compression</h3>

<p>当一张表中可能存在多个值，且这多个值存在在不同的地方，那么我们就可以通过字典的形式得到这些值所在的位置。</p>

<p><img src="https://imgur.com/GgSgrMr.png" alt="" /></p>

<p>这也是最常用的压缩方法。</p>]]></content><author><name>phrk</name><email>phrknfish@outlook.com</email></author><category term="CMU15-445" /><category term="数据库" /><category term="CMU15-445" /><summary type="html"><![CDATA[Tracker refer to Slide refer to Note mindmap root((Lecture 5)) Workloads OLTP OLAP HTAP Storage Models N-Ary DSM Columnar Compression Run-Length Encoding Bit-Packing Encoding Delta Encoding Incremental Encoding Dictionary Encoding Database workloads OLTP OLTP: On-Line Transaction Processing 每次快速的对一个小范围的数据进行读取、更新的操作。 OLAP OLAP: On-Line Analytical Processing OLAP 是用来支持复杂的分析操作，提供决策支持等 HTAP Hybrid Transaction + Analytical Processing 一种新的 workload ，将 OLTP 和 OOLAP 结合起来。 Stroage Models N-Ary Storage Model (NSM) 在 n-ary 的存储模式中，DBMS 连续的存储所有的、包含所有 arributes 的 tuple 在一个单独的页面中。 这对于 OLTP 来说是十分理想的。 Advantages: 插入，更新，删除非常快 对于需要整个 tuple 的查询非常友好 Disadvantages: 对于需要扫描整个表或者只需要一个属性的查询非常不好 Decompositrion Storage Model (DSM) 将所有 tuples 中的每个 attribute 单独分出来进行存储 也可以成为 “列存储 (column store)” 对于只读的 OLAP 操作非常友好，尤其是那些只需要扫描部分 attributes 的操作来说。 Advantages: 减少 I/O 的浪费 更好的进行查询以及将数据进行压缩 Disadvantages: 对于单点修改查询更新这些操作比较慢。 为了实现这种操作通常有两种操作方法。 为每个属性设置固定的字长，这样我们只需要得到 offset 就可以准确的查找到我们所需要的数据 一个更为罕见的操作是，使用一个形如 (id : pos) 的 tuple 来存储值，表示第 id 的值存储在 pos 位置上。 Database Compression I/O 是非常耗时的，通常是整个数据库的瓶颈，所以 DBMS 中广泛的采用压缩算法来提高 DBMS 的表现。 通常我们需要在 速度 和 压缩率 之间进行取舍。 压缩颗粒度 Block Level Tuple Level 对整个 tuple 进行压缩 (NSM Only) Attribute Level Columnar Level Naive Compression 使用 “general-purpose” 的压缩算法通常也是一种解决办法。不过一旦使用着这种方法之后，DBMS 就不知道我们进行操作的数据是什么，直到解压完。 provided as input: → LZO (1996), LZ4 (2011), Snappy (2011), Oracle OZIP (2014), Zstd (2015) 为了提高速度，我们需要另外的压缩方法，即使是在压缩之后，我们也有办法获取其中的信息来加速。 Columnar Compression Run-Length Encoding(RLE) 可以将一些连续出现在同一列上的值压缩成一个形如(value : pos : num) 的 triplets。 其中: value 表示值 pos 表示该值的起始位置 num 表示该值重复的次数 不过该方法可能存在一些缺陷 经过转换后 Bit-Packing Encoding 一些数据对我们来说是十分冗余的，我们可以通过 Bit-Packing 的方式来减少这些冗余。 将 int64 转换为 int8 大大减少了需要的空间。 不过该方法存在一些缺陷，可能会存在部分信息有不符合 int8 的信息。 因此，我们需要如下的方式进行存储。 不过该方法只能在额外存储信息较少的时候进行使用。 Bitmap Encoding 当我们每个 attribute 较少的时候，我们可以采用 Bitmap 的方式进行存储。 例如，只存在 F 和 M 两种值的时候，我们就可以是由 01 来表示是或者不是。 Delta Encoding 在许多情况下，例如室温多少，我们的统计结果里可能存在较为密集的值在一定的范围内。 因此我们通过确定一个值后，往后的所有值都可以通过 delta 的形式存储 Incremental Encoding 我们通常也可以通过取 前缀 / 后缀 的形式来得到我们的最终结果。 Dictionary Compression 当一张表中可能存在多个值，且这多个值存在在不同的地方，那么我们就可以通过字典的形式得到这些值所在的位置。 这也是最常用的压缩方法。]]></summary></entry><entry><title type="html">清泉之心</title><link href="https://blog.ohtoai.fun/2023/10/15/heart-of-Clean-Springs.html" rel="alternate" type="text/html" title="清泉之心" /><published>2023-10-15T13:12:29+00:00</published><updated>2023-10-15T13:12:29+00:00</updated><id>https://blog.ohtoai.fun/2023/10/15/heart-of-Clean-Springs</id><content type="html" xml:base="https://blog.ohtoai.fun/2023/10/15/heart-of-Clean-Springs.html"><![CDATA[<h2 id="剧情pv">剧情PV</h2>

<iframe width="854" height="480" src="https://www.youtube.com/embed/bdduDpNxknE" title="《原神》剧情PV-「清泉之心」" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<p>人们望向流水，叹息时光匆匆流淌。
而在清泉停驻的村庄，情思如湖光般澄亮。</p>

<blockquote>
  <p>“等待的时候是不觉得苦的，可是如果你真的回头了，我会觉得这一路的等待还是漫长了些。”</p>
</blockquote>

<h2 id="游戏文本">游戏文本</h2>

<p><a href="https://wiki.hoyolab.com/pc/genshin/entry/2323" class="button button--outline-secondary button--pill"><i class="fa-brands fa-wikipedia-w fa-bounce"></i>HoyoWiki!</a></p>

<h3 id="第一卷">第一卷</h3>

<p>清泉镇猎人们口口相传的传说故事，讲述了泉水精灵与不知名少年的相遇。<br />
如水的月光下，流泪的少年对清泉许下愿望。  <br />
远来的精灵客居无心的泉水之中，静静地倾听着无声的心愿。</p>

<p>泉水中的精灵并无悠远的记忆，也无深沉的梦想。她们来自水的精华，是无面目的天使之后裔。<br />
因而，当好奇的精灵从清泉中现身，从泪滴中听到少年的心声，便立刻对这更加年轻而脆弱的生命产生了兴趣。<br />
沉默的精灵伸出无形状的手指，轻触少年的额头与脸颊。同夜露一般冰凉，如失去的祝福一样柔软。</p>

<p>少年为陌生的感触惊醒，抬起头，正迎上精灵的目光。<br />
「你能替我实现愿望吗？」少年问道。<br />
泉水的精灵为唐突的发问惊讶不解，但她无法发声，只是轻轻点头。<br />
少年心满意足地离去。</p>

<p>他未曾知道，泉水精灵是孤独的。她没有友伴与亲人，也失却了大部分智慧。<br />
只有在泉水源源不断从石缝涌出，汇入池塘时，望着被涟漪击碎的月亮，她才渐渐获得思索的能力，渐渐能够模仿破碎的话语。<br />
好奇的精灵张望着这个世界，带着纯净的爱与无知，带着幼稚的灵性。她为偷吃浆果的狐狸与松鼠而欣喜，也为遮蔽银河的乌云哀伤。</p>

<p>对于那夜的少年，一种复杂却不成熟的感情在她的心中涌流。<br />
孤独的她既无力量也无智能，终究无法实现他的心愿。<br />
但她可以分担愿望，从他的烦恼中汲取生命，与他一同分享。</p>

<hr />

<h3 id="第二卷">第二卷</h3>
<p>清泉镇猎人们口口相传的传说故事，讲述了泉水精灵与少年的相识。<br />
望着涟漪中破碎的月光，少年向泉水倾诉真心。<br />
从他的话语中，她得知了他的许多故事。<br />
而从她的沉默中，他为自己坚定了信心。</p>

<p>泉水的精灵懵懂地明白，这世界上的美好不仅有月光与浆果，令人叹惋的黑暗也不仅有遮蔽夜空的层层乌云。<br />
少年向她讲述森林、城市与高墙，同她分享他的欢乐、哀伤与恐慌。<br />
而在倾听中，她为自己所新生的这个并不完美的世界日渐着迷。</p>

<p>当少年为自己的无力烦恼时，泉水的精灵温柔而沉默地替他拭去泪水。从他的泪水中，她对清泉之外的世界又多了几分理解。 <br />
泪水汇入池水，精灵将之净化，转变成为少年带来好梦的醴泉。少年则忘记了清醒时的一切伤痛，在梦中的清泉与沉默的精灵相会。</p>

<p>每当此时，月光溶融的池水中，安睡的精灵也展露笑颜。<br />
清露滋润着少年的美梦，少年的梦想也润湿了孤独的精灵。<br />
在梦中，泉水的精灵为少年讲述着遥远的水之国度，讲述着蓝宝石般的家乡，浅唱着流放者的乡愁，叹息着离乡与归宿。而少年则成了沉默的倾听者，为她的遭遇而流泪，为她的幸福而欣慰。</p>

<p>就这样，泉水精灵在少年的记忆与梦境中获得了言谈的能力。<br />
就这样，她与少年成为了无言不欢的朋友。</p>

<hr />

<h3 id="第三卷">第三卷</h3>
<p>清泉镇猎人们口口相传的传说故事，讲述了泉水精灵与少年许下诺言的故事。<br />
当夜风停止吹拂，池中的月亮复归圆满，少年第一次听到了精灵的声音。<br />
精灵生来便是比人类更加纤细而敏感的生灵，少年不禁为她哀歌一般温柔的语言入迷。</p>

<p>但精灵毕竟生来便是比人类更加纤细而敏感的生灵，透过少年的眼眸，她望见了无法隐瞒的思慕，与即将脱口而出的诺言。</p>

<p>突然间，精灵惊慌失措。</p>

<p>凡人的生命顽强却短暂，少年终将成长，终会老去。等到他褪去青涩与纯真，又将如何对待元素的纯净后裔？等到他年岁将衰，是否会自我责备，因一个幼稚的诺言而枉度一生？</p>

<p>泉水的精灵纯净而善良，但她并不懂得人界之爱。她未曾见识过人的奇迹，而只将千百年的变迁视作等闲。也正因此，她格外恐惧离别。</p>

<p>在人类看来奇迹般的守候，于元素之精灵看来只是短暂的美好。
而所爱之人的衰老，即使精灵的力量也无法挽回。</p>

<p>纤细的泉水精灵不忍目睹那一日不可逆转地降临，于是用一吻制止了少年。<br />
少年何其愚钝，竟将精灵冰凉的拒绝之吻误以为对诺言的认可。</p>

<p>在那一刻，精灵下定决心终会忍心离开少年。<br />
而少年则立下了永远陪伴在清泉旁边的誓言。</p>

<hr />

<h3 id="第四卷">第四卷</h3>
<p>清泉镇猎人们口口相传的传说故事，不再是少年的少年与不老的精灵终于面对苦涩的缺憾结局。<br />
后来，再后来，少年渐渐成长，交了新的朋友，有了新的经历。<br />
泉水的精灵依旧如同年轻时那样，为他安静地唱着每一首温柔的哀歌。</p>

<p>直到那一天，她终于离去，不再望向少年的方向。<br />
泉水叮咚作响不再汇成语言，涟漪中破碎的月亮也不再在水面的脚印中复合。<br />
泉水的精灵突然意识到，尽管找到了归宿，尽管经历了短暂的幸福，她仍然是孤独的。</p>

<p>不再是少年的少年没能意识到精灵的逃避，却将孤独归咎于自己。<br />
「或许她只是一个幼稚的幻梦。」<br />
听着清泉潺潺，他有时会这样想。</p>

<p>但那冰凉的一吻是真实的，就像曾戏弄她长发的夜风一般真实。<br />
突然间，他意识到，即使与无数新朋友相交相别，经历过无数冒险与归乡，他仍然是孤独的。</p>

<p>于是，像多年前那样，少年的眼泪落入清净的池塘，打湿了破碎的月亮。<br />
但这次，泉水精灵没有应约而来。<br />
她固执地背过身去，宁愿自视为一个童年纯洁的梦，一个自遥远异乡流浪而来的暂居客，也不愿以近乎永恒的寿命辜负爱慕之人的约定。</p>

<p>传说每当大雨降下，落入池塘的雨滴中间总会混杂着泉水精灵的泪滴。<br />
当少年终于老去，他依然对这样的无稽之谈深信不疑。<br />
不幸的是，逃避真心的泉水精灵同样对这等事实无法质疑。</p>]]></content><author><name>phrk</name><email>phrknfish@outlook.com</email></author><category term="game" /><summary type="html"><![CDATA[剧情PV 人们望向流水，叹息时光匆匆流淌。 而在清泉停驻的村庄，情思如湖光般澄亮。 “等待的时候是不觉得苦的，可是如果你真的回头了，我会觉得这一路的等待还是漫长了些。” 游戏文本 HoyoWiki! 第一卷 清泉镇猎人们口口相传的传说故事，讲述了泉水精灵与不知名少年的相遇。 如水的月光下，流泪的少年对清泉许下愿望。 远来的精灵客居无心的泉水之中，静静地倾听着无声的心愿。 泉水中的精灵并无悠远的记忆，也无深沉的梦想。她们来自水的精华，是无面目的天使之后裔。 因而，当好奇的精灵从清泉中现身，从泪滴中听到少年的心声，便立刻对这更加年轻而脆弱的生命产生了兴趣。 沉默的精灵伸出无形状的手指，轻触少年的额头与脸颊。同夜露一般冰凉，如失去的祝福一样柔软。 少年为陌生的感触惊醒，抬起头，正迎上精灵的目光。 「你能替我实现愿望吗？」少年问道。 泉水的精灵为唐突的发问惊讶不解，但她无法发声，只是轻轻点头。 少年心满意足地离去。 他未曾知道，泉水精灵是孤独的。她没有友伴与亲人，也失却了大部分智慧。 只有在泉水源源不断从石缝涌出，汇入池塘时，望着被涟漪击碎的月亮，她才渐渐获得思索的能力，渐渐能够模仿破碎的话语。 好奇的精灵张望着这个世界，带着纯净的爱与无知，带着幼稚的灵性。她为偷吃浆果的狐狸与松鼠而欣喜，也为遮蔽银河的乌云哀伤。 对于那夜的少年，一种复杂却不成熟的感情在她的心中涌流。 孤独的她既无力量也无智能，终究无法实现他的心愿。 但她可以分担愿望，从他的烦恼中汲取生命，与他一同分享。 第二卷 清泉镇猎人们口口相传的传说故事，讲述了泉水精灵与少年的相识。 望着涟漪中破碎的月光，少年向泉水倾诉真心。 从他的话语中，她得知了他的许多故事。 而从她的沉默中，他为自己坚定了信心。 泉水的精灵懵懂地明白，这世界上的美好不仅有月光与浆果，令人叹惋的黑暗也不仅有遮蔽夜空的层层乌云。 少年向她讲述森林、城市与高墙，同她分享他的欢乐、哀伤与恐慌。 而在倾听中，她为自己所新生的这个并不完美的世界日渐着迷。 当少年为自己的无力烦恼时，泉水的精灵温柔而沉默地替他拭去泪水。从他的泪水中，她对清泉之外的世界又多了几分理解。 泪水汇入池水，精灵将之净化，转变成为少年带来好梦的醴泉。少年则忘记了清醒时的一切伤痛，在梦中的清泉与沉默的精灵相会。 每当此时，月光溶融的池水中，安睡的精灵也展露笑颜。 清露滋润着少年的美梦，少年的梦想也润湿了孤独的精灵。 在梦中，泉水的精灵为少年讲述着遥远的水之国度，讲述着蓝宝石般的家乡，浅唱着流放者的乡愁，叹息着离乡与归宿。而少年则成了沉默的倾听者，为她的遭遇而流泪，为她的幸福而欣慰。 就这样，泉水精灵在少年的记忆与梦境中获得了言谈的能力。 就这样，她与少年成为了无言不欢的朋友。 第三卷 清泉镇猎人们口口相传的传说故事，讲述了泉水精灵与少年许下诺言的故事。 当夜风停止吹拂，池中的月亮复归圆满，少年第一次听到了精灵的声音。 精灵生来便是比人类更加纤细而敏感的生灵，少年不禁为她哀歌一般温柔的语言入迷。 但精灵毕竟生来便是比人类更加纤细而敏感的生灵，透过少年的眼眸，她望见了无法隐瞒的思慕，与即将脱口而出的诺言。 突然间，精灵惊慌失措。 凡人的生命顽强却短暂，少年终将成长，终会老去。等到他褪去青涩与纯真，又将如何对待元素的纯净后裔？等到他年岁将衰，是否会自我责备，因一个幼稚的诺言而枉度一生？ 泉水的精灵纯净而善良，但她并不懂得人界之爱。她未曾见识过人的奇迹，而只将千百年的变迁视作等闲。也正因此，她格外恐惧离别。 在人类看来奇迹般的守候，于元素之精灵看来只是短暂的美好。 而所爱之人的衰老，即使精灵的力量也无法挽回。 纤细的泉水精灵不忍目睹那一日不可逆转地降临，于是用一吻制止了少年。 少年何其愚钝，竟将精灵冰凉的拒绝之吻误以为对诺言的认可。 在那一刻，精灵下定决心终会忍心离开少年。 而少年则立下了永远陪伴在清泉旁边的誓言。 第四卷 清泉镇猎人们口口相传的传说故事，不再是少年的少年与不老的精灵终于面对苦涩的缺憾结局。 后来，再后来，少年渐渐成长，交了新的朋友，有了新的经历。 泉水的精灵依旧如同年轻时那样，为他安静地唱着每一首温柔的哀歌。 直到那一天，她终于离去，不再望向少年的方向。 泉水叮咚作响不再汇成语言，涟漪中破碎的月亮也不再在水面的脚印中复合。 泉水的精灵突然意识到，尽管找到了归宿，尽管经历了短暂的幸福，她仍然是孤独的。 不再是少年的少年没能意识到精灵的逃避，却将孤独归咎于自己。 「或许她只是一个幼稚的幻梦。」 听着清泉潺潺，他有时会这样想。 但那冰凉的一吻是真实的，就像曾戏弄她长发的夜风一般真实。 突然间，他意识到，即使与无数新朋友相交相别，经历过无数冒险与归乡，他仍然是孤独的。 于是，像多年前那样，少年的眼泪落入清净的池塘，打湿了破碎的月亮。 但这次，泉水精灵没有应约而来。 她固执地背过身去，宁愿自视为一个童年纯洁的梦，一个自遥远异乡流浪而来的暂居客，也不愿以近乎永恒的寿命辜负爱慕之人的约定。 传说每当大雨降下，落入池塘的雨滴中间总会混杂着泉水精灵的泪滴。 当少年终于老去，他依然对这样的无稽之谈深信不疑。 不幸的是，逃避真心的泉水精灵同样对这等事实无法质疑。]]></summary></entry><entry><title type="html">CMU15445 Project-Tracker</title><link href="https://blog.ohtoai.fun/cmu15-445/2023/10/02/CMU-Project-Tracker.html" rel="alternate" type="text/html" title="CMU15445 Project-Tracker" /><published>2023-10-02T01:48:08+00:00</published><updated>2023-10-23T03:12:45+00:00</updated><id>https://blog.ohtoai.fun/cmu15-445/2023/10/02/CMU-Project-Tracker</id><content type="html" xml:base="https://blog.ohtoai.fun/cmu15-445/2023/10/02/CMU-Project-Tracker.html"><![CDATA[<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/5mg3VB3Qh7jcR5kAAC4DSV?utm_source=generator" width="100%" height="152" frameborder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>

<h2 id="fall2022-project">Fall2022 Project</h2>

<pre><code class="language-mermaid">timeline
   title Project Schedule
   section Project 0 C++ Primer
      09.27 : TrieNode
      09.28 : TrieNodeWithValue / Trie
      09.29 : Debug -- pass

   section Project 1 Buffer Pool Manager
</code></pre>

<h3 id="project--0---c-primer">Project # 0 - C++ Primer</h3>

<p><a href="/cmu15-445/2023/09/27/CMU15445-project-0.html" class="button button--outline-secondary button--pill"><i class="fa-solid fa-database"></i> Project # 0 C++ Primer</a></p>

<ul>
  <li>环境配置</li>
  <li>C++ 基础语法</li>
</ul>

<p>参考:</p>
<ul>
  <li>写给[C++ ]新人智能指针避坑指南 <a href="https://www.luozhiyun.com/archives/762">https://www.luozhiyun.com/archives/762</a></li>
  <li>一文带你详细介绍c++中的<code class="language-plaintext highlighter-rouge">std::move</code>函数 <a href="https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html">https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html</a></li>
  <li>Introduction to C++11 and C++14 with Example Code Snippet <a href="https://www.thegeekstuff.com/2016/02/c-plus-plus-11/">https://www.thegeekstuff.com/2016/02/c-plus-plus-11/</a></li>
  <li>CMU 15445 vscode/clion clang12 cmake环境配置 <a href="https://zhuanlan.zhihu.com/p/592802373">https://zhuanlan.zhihu.com/p/592802373</a></li>
</ul>

<h3 id="project--1---buffer-pool-manager">Project # 1 - Buffer Pool Manager</h3>

<h3 id="project--2---b-tree-index-checkpoint-1">Project # 2 - B+ Tree Index Checkpoint 1</h3>

<h3 id="project--2---b-tree-index-checkpoint-2">Project # 2 - B+ Tree Index Checkpoint 2</h3>

<h3 id="project--3---query-execution">Project # 3 - Query Execution</h3>

<h3 id="project--4---concurrency-control">Project # 4 - Concurrency Control</h3>

<hr />

<h2 id="fall2022-lectrue">Fall2022 Lectrue</h2>

<pre><code class="language-mermaid">timeline
   title Lectrue Schedule
      09.27  : Lecture 1
      09.29  : Lecture 2
      10.07  : Lecture 3
             : Lecture 4
      10.09  : Lecture 5
      10.27  : Lectrue 6
</code></pre>

<p><a href="/cmu15-445/2023/10/19/Lecture-5-Storage-Models-Compression.html" class="button button--outline-secondary button--pill"><i class="fa-regular fa-note-sticky"></i> Lecture #05: Storage Models &amp; Compression</a></p>

<p><a href="/cmu15-445/2023/10/23/Lecture-6-Memory-Management.html" class="button button--outline-secondary button--pill"><i class="fa-regular fa-note-sticky"></i> Lecture #06: Memory Management</a></p>]]></content><author><name>phrk</name><email>phrknfish@outlook.com</email></author><category term="CMU15-445" /><category term="CMU15-445" /><category term="数据库" /><category term="C++" /><category term="Trie_Tree" /><summary type="html"><![CDATA[Fall2022 Project timeline title Project Schedule section Project 0 C++ Primer 09.27 : TrieNode 09.28 : TrieNodeWithValue / Trie 09.29 : Debug -- pass section Project 1 Buffer Pool Manager Project # 0 - C++ Primer Project # 0 C++ Primer 环境配置 C++ 基础语法 参考: 写给[C++ ]新人智能指针避坑指南 https://www.luozhiyun.com/archives/762 一文带你详细介绍c++中的std::move函数 https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html Introduction to C++11 and C++14 with Example Code Snippet https://www.thegeekstuff.com/2016/02/c-plus-plus-11/ CMU 15445 vscode/clion clang12 cmake环境配置 https://zhuanlan.zhihu.com/p/592802373 Project # 1 - Buffer Pool Manager Project # 2 - B+ Tree Index Checkpoint 1 Project # 2 - B+ Tree Index Checkpoint 2 Project # 3 - Query Execution Project # 4 - Concurrency Control Fall2022 Lectrue timeline title Lectrue Schedule 09.27 : Lecture 1 09.29 : Lecture 2 10.07 : Lecture 3 : Lecture 4 10.09 : Lecture 5 10.27 : Lectrue 6 Lecture #05: Storage Models &amp; Compression Lecture #06: Memory Management]]></summary></entry><entry><title type="html">CMU15445 Project 0 Trie_Tree</title><link href="https://blog.ohtoai.fun/cmu15-445/2023/09/27/CMU15445-project-0.html" rel="alternate" type="text/html" title="CMU15445 Project 0 Trie_Tree" /><published>2023-09-27T14:44:40+00:00</published><updated>2023-10-02T15:49:09+00:00</updated><id>https://blog.ohtoai.fun/cmu15-445/2023/09/27/CMU15445-project-0</id><content type="html" xml:base="https://blog.ohtoai.fun/cmu15-445/2023/09/27/CMU15445-project-0.html"><![CDATA[<p><a href="/cmu15-445/2023/10/02/CMU-Project-Tracker.html" class="button button--outline-secondary button--pill"><i class="fa-solid fa-link"></i> Tracker</a></p>

<h2 id="实验目标">实验目标</h2>

<p>该实验为 <code class="language-plaintext highlighter-rouge">CMU 15-445/645</code> 的前置实现。主要考察 C++ 使用的功底。</p>

<p>我所采用的课程为 <a href="https://15445.courses.cs.cmu.edu/fall2022/">fall2022</a><sup id="fnref:cmu_15445_fall2022" role="doc-noteref"><a href="#fn:cmu_15445_fall2022" class="footnote" rel="footnote">1</a></sup> 相关代码可以在 <a href="https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall">Release</a><sup id="fnref:bustub_source_code" role="doc-noteref"><a href="#fn:bustub_source_code" class="footnote" rel="footnote">2</a></sup> 中下载</p>

<p>该课程主要涉及到两方面内容</p>

<ul>
  <li>如何搭建环境</li>
  <li>C++的使用</li>
</ul>

<pre><code class="language-mermaid">classDiagram
class TrieNode {
 + TrieNode(char keychar)
 + TrieNode(TrieNode &amp;&amp;orher_trie_node)
 + HasChild(char key_char) bool
 + HasChildren() bool
 + IsEndNode() bool
 + GetKeyChar() char
 + InsertChildNode(char key_char, unique_ptr~TrieNode~ &amp;&amp; child) unque_ptr~TrieNode~
 + GetChildNode(char key_char) unique_ptr~TrieNode~
 + RemoveChildNode(char key_char) void
 + SetEndNode(bool is_end) void
 # char key_char_
 # bool is_end_
 # unordered_map |char, unique_ptr~TrieNode~| children_
}

class TrieNodeWithValue {
 - T value_
 + TrieNodeWithValue(TrieNode &amp;&amp;trieNode, T value)
 + TrieNodeWithValue(char key_char, T value)
 + T GetValue() T
}

TrieNode &lt;|-- TrieNodeWithValue
</code></pre>

<pre><code class="language-mermaid">classDiagram
class Trie {
 - std::unique_ptr~TrieNode~ root_
 - ReaderWriterLatch latch_
 + Trie()
 + Insert(const std::string &amp;key, T value) bool
 + Remove(const std::string &amp;key,) bool
 + GetValue(const std::string &amp;key, bool success) T
}
</code></pre>

<h2 id="环境的搭建">环境的搭建</h2>

<p>我采用的是使用虚拟机(Ubuntu) + 本地电脑ssh 的开发方式。</p>

<p>vscode 中安装如下几个插件</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">C/C++</code></li>
  <li><code class="language-plaintext highlighter-rouge">CMake</code></li>
  <li><code class="language-plaintext highlighter-rouge">CMake Tools</code></li>
  <li><code class="language-plaintext highlighter-rouge">Remote - SSH</code></li>
</ul>

<p>首先我们首先需要下载并解压所需要的 <a href="https://github.com/cmu-db/bustub/releases/tag/v20221128-2022fall">代码</a></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://github.com/cmu-db/bustub/archive/refs/tags/v20221128-2022fall.tar.gz
<span class="nb">tar</span> <span class="nt">-zxvf</span> v20221128-2022fall.tar.gz  
</code></pre></div></div>

<p>然后直接用 <code class="language-plaintext highlighter-rouge">VScode</code> SSH直接进入远程的电脑的当前目录下。</p>

<p>之后安装必要的软件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>build_support/packages.sh
</code></pre></div></div>

<p>之后看 Vscode 几个选项需要我们设置一下</p>

<div id="tmp_tag"></div>
<p><img src="https://s2.loli.net/2023/10/01/1zx8TOX9fcWYEF2.png" alt="VSCODE" /></p>

<p>我们点击最下方的</p>

<p><a href="#tmp_tag" class="button button--outline-secondary button--pill"><i class="fa-solid fa-gear fa-beat"></i> 生成</a></p>

<p><img src="https://s2.loli.net/2023/10/01/RcEXkCSA9uOsj1I.png" alt="image-20231001205625799" /></p>

<p>然后选择 <code class="language-plaintext highlighter-rouge">Clang 12.01 x86_64-pc-linux-gnu</code> 即可愉快的coding了。</p>

<h3 id="debug">Debug</h3>

<p>在 <i class="fa-solid fa-gear fa-beat"></i> 生成旁边有个按钮 <code class="language-plaintext highlighter-rouge">[all]</code> 把他切换为你所需要的那个就可以了。</p>

<p><img src="https://s2.loli.net/2023/10/02/MRDE97WAlb5ht6w.png" alt="" /></p>

<p>所采用的测试方法为 <code class="language-plaintext highlighter-rouge">GTest</code></p>

<p>只需要将目标 Test 文件下的 <code class="language-plaintext highlighter-rouge">DIABLE_</code> 删除就可以进行 Test 了</p>

<p>例如在路径 <code class="language-plaintext highlighter-rouge">/test/primer/starter_trie_test.cpp</code> 将所有 <code class="language-plaintext highlighter-rouge">DIABLE_</code> 删除，之后就可以尝试输出结果，按 <i class="fa-solid fa-bug"></i> 就可以在自己打的断点进行调试。按 <i class="fa-solid fa-play"></i> 就可以直接出结果</p>

<blockquote>
  <p><i class="fa-solid fa-bug"></i> 调试
<img src="https://s2.loli.net/2023/10/02/hXI9qEDSOpasglx.png" alt="Debug &quot;你正在调试&quot;" /></p>
</blockquote>

<blockquote>
  <p><i class="fa-solid fa-play"></i> 运行结果
<img src="https://s2.loli.net/2023/10/02/2F1ToQA6LgkyvID.png" alt="Run &quot;运行代码的结果&quot;" /></p>
</blockquote>

<h2 id="c-的使用">C++ 的使用</h2>

<p>这方面到没有太多可以讲的。</p>

<p>主要抓住 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 的用法就可以了。</p>

<p>下面是几个个使用的例子。</p>

<p>遍历字典树的节点</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">root_</span><span class="p">;</span> <span class="c1">// ! 指向智能指针的指针</span>
<span class="k">auto</span> <span class="n">par_node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="p">;</span>

<span class="k">while</span><span class="p">(</span><span class="n">cur_node</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cur_node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span> <span class="n">GetChildNode</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="n">par_node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如何在父类指针上动态构建子类节点</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">tmp_node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">cur_node</span><span class="p">)</span> <span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="n">par_node</span><span class="o">-&gt;</span> <span class="n">get</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">InsertChildNode</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_node</span><span class="p">));</span>
<span class="n">cur_node</span> <span class="o">=</span> <span class="n">par_node</span><span class="o">-&gt;</span> <span class="n">GetChildNode</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
</code></pre></div></div>

<p>通过强制转换得到子类空间的值</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">tmp_node</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">TrieNodeWithValue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">cur_node</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">());</span>
</code></pre></div></div>

<p>由于课程已经结束了，实在无法完成的话，可以参考我的<a href="/assets/others/CMU15445_project_0_c++_prime.cpp">代码</a>。</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:cmu_15445_fall2022" role="doc-endnote">
      <p>CMU 15-445/645 fall2022 官方网址 <a href="https://15445.courses.cs.cmu.edu/fall2022/">https://15445.courses.cs.cmu.edu/fall2022/</a> <a href="#fnref:cmu_15445_fall2022" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:bustub_source_code" role="doc-endnote">
      <p>bustub 源码地址 <a href="https://github.com/cmu-db/bustub">https://github.com/cmu-db/bustub</a> <a href="#fnref:bustub_source_code" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>phrk</name><email>phrknfish@outlook.com</email></author><category term="CMU15-445" /><category term="CMU15-445" /><category term="数据库" /><category term="C++" /><category term="Trie_Tree" /><summary type="html"><![CDATA[Tracker 实验目标 该实验为 CMU 15-445/645 的前置实现。主要考察 C++ 使用的功底。 我所采用的课程为 fall20221 相关代码可以在 Release2 中下载 该课程主要涉及到两方面内容 如何搭建环境 C++的使用 classDiagram class TrieNode { + TrieNode(char keychar) + TrieNode(TrieNode &amp;&amp;orher_trie_node) + HasChild(char key_char) bool + HasChildren() bool + IsEndNode() bool + GetKeyChar() char + InsertChildNode(char key_char, unique_ptr~TrieNode~ &amp;&amp; child) unque_ptr~TrieNode~ + GetChildNode(char key_char) unique_ptr~TrieNode~ + RemoveChildNode(char key_char) void + SetEndNode(bool is_end) void # char key_char_ # bool is_end_ # unordered_map |char, unique_ptr~TrieNode~| children_ } class TrieNodeWithValue { - T value_ + TrieNodeWithValue(TrieNode &amp;&amp;trieNode, T value) + TrieNodeWithValue(char key_char, T value) + T GetValue() T } TrieNode &lt;|-- TrieNodeWithValue classDiagram class Trie { - std::unique_ptr~TrieNode~ root_ - ReaderWriterLatch latch_ + Trie() + Insert(const std::string &amp;key, T value) bool + Remove(const std::string &amp;key,) bool + GetValue(const std::string &amp;key, bool success) T } 环境的搭建 我采用的是使用虚拟机(Ubuntu) + 本地电脑ssh 的开发方式。 vscode 中安装如下几个插件 C/C++ CMake CMake Tools Remote - SSH 首先我们首先需要下载并解压所需要的 代码 wget https://github.com/cmu-db/bustub/archive/refs/tags/v20221128-2022fall.tar.gz tar -zxvf v20221128-2022fall.tar.gz 然后直接用 VScode SSH直接进入远程的电脑的当前目录下。 之后安装必要的软件 sudo build_support/packages.sh 之后看 Vscode 几个选项需要我们设置一下 我们点击最下方的 生成 然后选择 Clang 12.01 x86_64-pc-linux-gnu 即可愉快的coding了。 Debug 在 生成旁边有个按钮 [all] 把他切换为你所需要的那个就可以了。 所采用的测试方法为 GTest 只需要将目标 Test 文件下的 DIABLE_ 删除就可以进行 Test 了 例如在路径 /test/primer/starter_trie_test.cpp 将所有 DIABLE_ 删除，之后就可以尝试输出结果，按 就可以在自己打的断点进行调试。按 就可以直接出结果 调试 运行结果 C++ 的使用 这方面到没有太多可以讲的。 主要抓住 std::unique_ptr 的用法就可以了。 下面是几个个使用的例子。 遍历字典树的节点 auto cur_node = &amp;this-&gt;root_; // ! 指向智能指针的指针 auto par_node = cur_node; while(cur_node != nullptr) { cur_node = cur_node-&gt;get()-&gt; GetChildNode(ch); ... par_node = cur_node; } 如何在父类指针上动态构建子类节点 auto tmp_node = std::make_unique&lt;T&gt;(std::move(*cur_node) , value); par_node-&gt; get() -&gt; InsertChildNode(ch, std::move(*tmp_node)); cur_node = par_node-&gt; GetChildNode(ch); 通过强制转换得到子类空间的值 auto tmp_node = dynamic_cast&lt;TrieNodeWithValue&lt;T&gt; *&gt;(cur_node-&gt;get()); 由于课程已经结束了，实在无法完成的话，可以参考我的代码。 CMU 15-445/645 fall2022 官方网址 https://15445.courses.cs.cmu.edu/fall2022/ &#8617; bustub 源码地址 https://github.com/cmu-db/bustub &#8617;]]></summary></entry><entry><title type="html">小林coding 图解计算机网络</title><link href="https://blog.ohtoai.fun/2023/09/13/NW-xiaoling.html" rel="alternate" type="text/html" title="小林coding 图解计算机网络" /><published>2023-09-13T20:32:27+00:00</published><updated>2023-09-13T20:32:27+00:00</updated><id>https://blog.ohtoai.fun/2023/09/13/NW-xiaoling</id><content type="html" xml:base="https://blog.ohtoai.fun/2023/09/13/NW-xiaoling.html"><![CDATA[<p>[ ] TODO</p>

<hr />

<h2 id="二基础篇">二、基础篇</h2>

<h3 id="21-tcpip-网络模型有哪几层">2.1 TCP/IP 网络模型有哪几层？</h3>

<h4 id="应用层">应用层</h4>

<p>应用层只需要专注为用户提供应用功能，例如HTTP、FTP等。</p>

<p>应用层不会去关心如何传输</p>

<h4 id="传输层">传输层</h4>

<p>传输层，为应用层提供网络支持，目前有两个传输协议，TCP 和 UDP。</p>

<p>TCP相较于UDP多了许多特性，例如 流量控制、超时重传、拥塞控制等。这些都是为了保证数据包能可靠的传输给对方。</p>

<h4 id="网络层">网络层</h4>

<p>网络层主要确保可以将数据发送给另外一个设备</p>

<h4 id="网络接口层">网络接口层</h4>

<p>负责两个直接相连的设备连接</p>

<h4 id="总结">总结</h4>

<p><img src="https://s2.loli.net/2023/09/25/JYZdsStFG6IpL1b.png" alt="" /></p>

<h3 id="22-键入网址到网页显示期间发生了什么">2.2 键入网址到网页显示，期间发生了什么？</h3>

<h4 id="http">HTTP</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://xiaolincoding.com/network/1_base/what_happen_url.html
|-1--|  |---2-----------| |--3-------------------------------|
</code></pre></div></div>

<p><img src="https://s2.loli.net/2023/09/25/p19sEXfv4CoWmaN.jpg" alt="" /></p>

<p>如果没有路径名称的时候就我们就需要先访问我们的<strong>默认文件</strong>，是<code class="language-plaintext highlighter-rouge">/index.html</code>或者<code class="language-plaintext highlighter-rouge">/default.html</code>这些文件。</p>

<p>在对<code class="language-plaintext highlighter-rouge">URL</code>完成解析之后，浏览器确定了 Web 服务器额文件名， 接下来就是根据这些信息生成 HTTP 请求的消息了。</p>

<p><img src="https://s2.loli.net/2023/09/25/wG5rdVCse1PJqZA.png" alt="" /></p>

<h4 id="dns">DNS</h4>

<p>在发送http消息之前我们需要找寻到一个服<strong>务器域名所对应的 IP 地址</strong>。</p>

<p>域名是使用 <code class="language-plaintext highlighter-rouge">.</code> 来进行分割，越靠右层级越高。</p>

<p>例如 <code class="language-plaintext highlighter-rouge">www.xiaolingcoding.com.</code> 中，最后一个点代表了根域名。</p>

<p>DNS解析可以看成如下图所述的过程。</p>

<p><img src="https://s2.loli.net/2023/09/25/PyulZ7eSMjxO1Rk.png" alt="" /></p>

<h4 id="协议栈">协议栈</h4>

<p>通过DNS服务器获取到IP之后就可以将 HTTP 所获的传输工作交给操作系统中的<strong>协议栈</strong>。</p>

<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg" alt="" /></p>

<p>在 IP 协议中还有两个协议 <code class="language-plaintext highlighter-rouge">ICMP</code> 和 <code class="language-plaintext highlighter-rouge">ARP</code> 协议</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li>
  <li><code class="language-plaintext highlighter-rouge">ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li>
</ul>

<h4 id="tcp">TCP</h4>

<h4 id="ip">IP</h4>

<h4 id="mac">MAC</h4>

<h4 id="网卡">网卡</h4>

<h4 id="交换机">交换机</h4>

<h2 id="三http篇">三、HTTP篇</h2>

<h3 id="31-http-常见面试题">3.1 HTTP 常见面试题</h3>

<h4 id="强制缓存">强制缓存</h4>

<p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>]]></content><author><name>phrk</name><email>phrknfish@outlook.com</email></author><category term="八股" /><category term="网络" /><summary type="html"><![CDATA[[ ] TODO 二、基础篇 2.1 TCP/IP 网络模型有哪几层？ 应用层 应用层只需要专注为用户提供应用功能，例如HTTP、FTP等。 应用层不会去关心如何传输 传输层 传输层，为应用层提供网络支持，目前有两个传输协议，TCP 和 UDP。 TCP相较于UDP多了许多特性，例如 流量控制、超时重传、拥塞控制等。这些都是为了保证数据包能可靠的传输给对方。 网络层 网络层主要确保可以将数据发送给另外一个设备 网络接口层 负责两个直接相连的设备连接 总结 2.2 键入网址到网页显示，期间发生了什么？ HTTP https://xiaolincoding.com/network/1_base/what_happen_url.html |-1--| |---2-----------| |--3-------------------------------| 如果没有路径名称的时候就我们就需要先访问我们的默认文件，是/index.html或者/default.html这些文件。 在对URL完成解析之后，浏览器确定了 Web 服务器额文件名， 接下来就是根据这些信息生成 HTTP 请求的消息了。 DNS 在发送http消息之前我们需要找寻到一个服务器域名所对应的 IP 地址。 域名是使用 . 来进行分割，越靠右层级越高。 例如 www.xiaolingcoding.com. 中，最后一个点代表了根域名。 DNS解析可以看成如下图所述的过程。 协议栈 通过DNS服务器获取到IP之后就可以将 HTTP 所获的传输工作交给操作系统中的协议栈。 在 IP 协议中还有两个协议 ICMP 和 ARP 协议 ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。 ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。 TCP IP MAC 网卡 交换机 三、HTTP篇 3.1 HTTP 常见面试题 强制缓存 强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。]]></summary></entry><entry><title type="html">小林coding 图解操作系统</title><link href="https://blog.ohtoai.fun/2023/09/12/OS-xiaoling.html" rel="alternate" type="text/html" title="小林coding 图解操作系统" /><published>2023-09-12T09:24:00+00:00</published><updated>2023-09-13T20:31:04+00:00</updated><id>https://blog.ohtoai.fun/2023/09/12/OS-xiaoling</id><content type="html" xml:base="https://blog.ohtoai.fun/2023/09/12/OS-xiaoling.html"><![CDATA[<p>[ ] TODO</p>

<hr />

<h2 id="二硬件结构">二、硬件结构</h2>

<h3 id="21-cpu是如何执行程序的">2.1 CPU是如何执行程序的？</h3>

<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%B7%A5%E4%BD%9C%E7%BB%84%E4%BB%B6.png" alt="CPU执行指令" /></p>

<h2 id="22-磁盘比内存慢几万倍">2.2 磁盘比内存慢几万倍</h2>

<h2 id="三操作系统结构">三、操作系统结构</h2>

<h3 id="41-linux-内核-vs-windows-内核">4.1 Linux 内核 VS windows 内核</h3>

<p>计算机是由各种外部硬件设备组成的，比如内存、cpu、硬盘等，如果每个应用都要和这些硬件设备对接通信协议，那这样太累了，所以这个中间人就由内核来负责，<strong>让内核作为应用连接硬件设备的桥梁</strong>，应用程序只需关心与内核交互，不用关心硬件的细节。</p>

<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8/Kernel_Layout.png" alt="nehe" /></p>

<p>现代操作系统的内核一般提供 4 个基本能力</p>

<ul>
  <li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；</li>
  <li>管理内存，决定内存的分配和回收，也就是内存管理的能力；</li>
  <li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；</li>
  <li>提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</li>
</ul>

<p>通常来说内核具有比较高的权限，可以控制CPU、内存、硬盘等硬件通常操作系统会被分为两个区域</p>

<ul>
  <li>内核空间，只有内核程序可以访问</li>
  <li>用户空间，提供给应用程序使用</li>
</ul>

<h2 id="四内存管理">四、内存管理</h2>

<h3 id="41-为什么要有虚拟内存">4.1 为什么要有虚拟内存</h3>

<h4 id="虚拟内存">虚拟内存</h4>

<p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p>

<p><img src="https://cdn.xiaolincoding.com//mysql/other/72ab76ba697e470b8ceb14d5fc5688d9.png" alt="" /></p>

<h4 id="内存分段">内存分段</h4>

<p>不同的段是由不同的属性，用分段的形式将这些段分离出来。</p>

<p>分段机制下，虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。</p>

<p><img src="https://cdn.xiaolincoding.com//mysql/other/a9ed979e2ed8414f9828767592aadc21.png" alt="" /></p>

<p>分段的办法也有不足之处</p>

<ul>
  <li>内存碎片</li>
  <li>内存交换的效率低</li>
</ul>

<h4 id="内存分页">内存分页</h4>

<p><img src="https://cdn.xiaolincoding.com//mysql/other/08a8e315fedc4a858060db5cb4a654af.png" alt="" /></p>

<p>在使用的过程中，我们只需要换出不常用的，换入需要用的，就可以提升内存的交换效率。更进一步的，<strong>只有在程序运行中，需要用到对应虚拟内存也里面的指令和数据是，再加载到物理内存里去</strong>。</p>

<p><img src="https://cdn.xiaolincoding.com//mysql/other/388a29f45fe947e5a49240e4eff13538-20230309234651917.png" alt="" /></p>

<p>分页对应的映射</p>

<p><img src="https://cdn.xiaolincoding.com//mysql/other/7884f4d8db4949f7a5bb4bbd0f452609.png" alt="" /></p>

<h5 id="多级页表">多级页表</h5>

<p><img src="https://cdn.xiaolincoding.com//mysql/other/19296e249b2240c29f9c52be70f611d5.png" alt="" /></p>

<p>现代六十四位处理系统一般采用四级目录。</p>

<h5 id="tlb">TLB</h5>

<p>由于局部性原理，我们会在短时间内大量访问同一段内的指令。</p>]]></content><author><name>phrk</name><email>phrknfish@outlook.com</email></author><category term="OS" /><category term="操作系统" /><category term="八股" /><summary type="html"><![CDATA[[ ] TODO 二、硬件结构 2.1 CPU是如何执行程序的？ 2.2 磁盘比内存慢几万倍 三、操作系统结构 4.1 Linux 内核 VS windows 内核 计算机是由各种外部硬件设备组成的，比如内存、cpu、硬盘等，如果每个应用都要和这些硬件设备对接通信协议，那这样太累了，所以这个中间人就由内核来负责，让内核作为应用连接硬件设备的桥梁，应用程序只需关心与内核交互，不用关心硬件的细节。 现代操作系统的内核一般提供 4 个基本能力 管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力； 管理内存，决定内存的分配和回收，也就是内存管理的能力； 管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力； 提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。 通常来说内核具有比较高的权限，可以控制CPU、内存、硬盘等硬件通常操作系统会被分为两个区域 内核空间，只有内核程序可以访问 用户空间，提供给应用程序使用 四、内存管理 4.1 为什么要有虚拟内存 虚拟内存 操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示： 内存分段 不同的段是由不同的属性，用分段的形式将这些段分离出来。 分段机制下，虚拟地址由两部分组成，段选择因子和段内偏移量。 分段的办法也有不足之处 内存碎片 内存交换的效率低 内存分页 在使用的过程中，我们只需要换出不常用的，换入需要用的，就可以提升内存的交换效率。更进一步的，只有在程序运行中，需要用到对应虚拟内存也里面的指令和数据是，再加载到物理内存里去。 分页对应的映射 多级页表 现代六十四位处理系统一般采用四级目录。 TLB 由于局部性原理，我们会在短时间内大量访问同一段内的指令。]]></summary></entry><entry><title type="html">二叉树打印模板</title><link href="https://blog.ohtoai.fun/algorithm/acm_template/2022/08/12/binary-tree-print.html" rel="alternate" type="text/html" title="二叉树打印模板" /><published>2022-08-12T00:00:00+00:00</published><updated>2022-08-12T20:35:22+00:00</updated><id>https://blog.ohtoai.fun/algorithm/acm_template/2022/08/12/binary-tree-print</id><content type="html" xml:base="https://blog.ohtoai.fun/algorithm/acm_template/2022/08/12/binary-tree-print.html"><![CDATA[<p>该代码仅作为赛时模板使用，为了方便调试信息，以反转区间为例。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">son</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">par</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>

   <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
      <span class="n">par</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">sz</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span> <span class="n">Tree</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">upd_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">sz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">sz</span> <span class="o">+</span> <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]].</span><span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">_rotate</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">par</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">par</span><span class="p">;</span>

   <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">;</span>

   <span class="n">Tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">d</span> <span class="o">^</span> <span class="mi">1</span><span class="p">];</span>
   <span class="n">Tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">d</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="n">Tree</span><span class="p">[</span><span class="n">z</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">z</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

   <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">d</span><span class="p">]].</span><span class="n">par</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
   <span class="n">Tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">par</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
   <span class="n">Tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">par</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>

   <span class="n">upd_size</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
   <span class="n">upd_size</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">lflg</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">rflg</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="p">(</span><span class="n">now</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"val:"</span><span class="p">;</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-inf"</span><span class="p">;</span>
         <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mf">1e7</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" inf"</span><span class="p">;</span>
         <span class="k">else</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fixed</span> <span class="o">&lt;&lt;</span> <span class="n">right</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">val</span><span class="p">;</span>
         <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"tag:"</span><span class="p">;</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fixed</span> <span class="o">&lt;&lt;</span> <span class="n">right</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">val</span><span class="p">;</span>
         <span class="k">break</span><span class="p">;</span>

      <span class="nl">default:</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">""</span><span class="p">;</span>
         <span class="k">break</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_branch</span><span class="p">(</span><span class="kt">int</span> <span class="n">dep</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">square</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">auto</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">square</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">column</span> <span class="o">&lt;=</span> <span class="n">dep</span><span class="p">;</span> <span class="n">column</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" |"</span><span class="p">[(</span><span class="n">rflg</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">lflg</span><span class="p">[</span><span class="n">column</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">||</span>
                      <span class="p">(</span><span class="n">lflg</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">rflg</span><span class="p">[</span><span class="n">column</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">||</span>
                      <span class="p">(</span><span class="n">column</span> <span class="o">==</span> <span class="n">dep</span><span class="p">)];</span>
      <span class="p">}</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_val</span><span class="p">(</span><span class="kt">int</span> <span class="n">dep</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">square</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">auto</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">square</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">column</span> <span class="o">&lt;</span> <span class="n">dep</span><span class="p">;</span> <span class="n">column</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" |"</span><span class="p">[(</span><span class="n">rflg</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">lflg</span><span class="p">[</span><span class="n">column</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">||</span>
                      <span class="p">(</span><span class="n">lflg</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">rflg</span><span class="p">[</span><span class="n">column</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])];</span>
      <span class="p">}</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'-'</span><span class="p">;</span>
      <span class="n">print_list</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">val</span><span class="p">[</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pt_tree</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">square</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dep</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
   <span class="n">lflg</span><span class="p">[</span><span class="n">dep</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">pt_tree</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">square</span><span class="p">,</span> <span class="n">dep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="n">print_branch</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span> <span class="n">square</span><span class="p">);</span>
   <span class="n">rflg</span><span class="p">[</span><span class="n">dep</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">print_val</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span> <span class="n">square</span><span class="p">,</span> <span class="p">{</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span><span class="p">,</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">tag</span><span class="p">});</span>
   <span class="n">lflg</span><span class="p">[</span><span class="n">dep</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="n">print_branch</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span> <span class="n">square</span><span class="p">);</span>
   <span class="n">pt_tree</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">square</span><span class="p">,</span> <span class="n">dep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
   <span class="n">rflg</span><span class="p">[</span><span class="n">dep</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">push_down</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">tag</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]].</span><span class="n">tag</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">swap</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">splay</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tar</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">par</span> <span class="o">!=</span> <span class="n">tar</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">push_down</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
      <span class="kt">int</span> <span class="n">cop</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">par</span><span class="p">,</span> <span class="n">cgp</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cop</span><span class="p">].</span><span class="n">par</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cgp</span> <span class="o">!=</span> <span class="n">tar</span><span class="p">)</span>
         <span class="k">if</span> <span class="p">((</span><span class="n">Tree</span><span class="p">[</span><span class="n">cgp</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cop</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cop</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur</span><span class="p">))</span>
            <span class="n">_rotate</span><span class="p">(</span><span class="n">cop</span><span class="p">);</span>
         <span class="k">else</span>
            <span class="n">_rotate</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
      <span class="n">_rotate</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">tar</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">root</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">,</span> <span class="n">par</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">push_down</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
      <span class="n">par</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
      <span class="n">cur</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span><span class="p">];</span>
   <span class="p">}</span>
   <span class="n">id</span><span class="o">++</span><span class="p">;</span>
   <span class="n">Tree</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">par</span><span class="p">);</span>
   <span class="n">Tree</span><span class="p">[</span><span class="n">par</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">Tree</span><span class="p">[</span><span class="n">par</span><span class="p">].</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
   <span class="n">splay</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">,</span> <span class="n">par</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">push_down</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
      <span class="n">par</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">sz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
      <span class="n">cur</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span> <span class="n">sz</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reverse</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">l</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
   <span class="n">splay</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="n">r</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
   <span class="n">splay</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

   <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">tag</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">splay</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

   <span class="n">pt_tree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
   <span class="n">push_down</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
   <span class="n">print</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mf">1e7</span><span class="p">)</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
   <span class="n">print</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
   <span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mf">1e9</span><span class="p">);</span>
   <span class="n">insert</span><span class="p">(</span><span class="mf">1e9</span><span class="p">);</span>

   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

   <span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
      <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">l</span> <span class="o">&gt;&gt;</span> <span class="n">r</span><span class="p">;</span>
      <span class="n">reverse</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="n">print</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>phrk</name><email>phrknfish@outlook.com</email></author><category term="algorithm" /><category term="ACM_template" /><category term="Splay" /><summary type="html"><![CDATA[该代码仅作为赛时模板使用，为了方便调试信息，以反转区间为例。 #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; const int N = 1e5 + 10; struct Node { int val; int son[2], par; int sz; int tag; void init(int v, int p) { val = v; par = p; son[0] = son[1] = 0; sz = 1; tag = 0; } } Tree[N]; void upd_size(int x) { Tree[x].sz = 1 + Tree[Tree[x].son[0]].sz + Tree[Tree[x].son[1]].sz; } int root = 0, id = 0; void _rotate(int x) { int y = Tree[x].par; int z = Tree[y].par; int d = Tree[y].son[1] == x; Tree[y].son[d] = Tree[x].son[d ^ 1]; Tree[x].son[d ^ 1] = y; if (z) Tree[z].son[Tree[z].son[1] == y] = x; Tree[Tree[y].son[d]].par = y; Tree[y].par = x; Tree[x].par = z; upd_size(y); upd_size(x); } int lflg[N], rflg[N]; void print_list(int now, int val) { switch (now) { case 1: cout &lt;&lt; "val:"; if (val &lt; 0) cout &lt;&lt; "-inf"; else if (val &gt; 1e7) cout &lt;&lt; " inf"; else cout &lt;&lt; fixed &lt;&lt; right &lt;&lt; setw(4) &lt;&lt; val; break; case 2: cout &lt;&lt; "tag:"; cout &lt;&lt; fixed &lt;&lt; right &lt;&lt; setw(4) &lt;&lt; val; break; default: cout &lt;&lt; ""; break; } } void print_branch(int dep, pair&lt;int, int&gt; square) { auto [x, y] = square; for (int row = 1; row &lt;= x; row++) { for (int column = 1; column &lt;= dep; column++) { for (int i = 1; i &lt; y; i++) cout &lt;&lt; ' '; cout &lt;&lt; " |"[(rflg[column] &amp;&amp; lflg[column + 1]) || (lflg[column] &amp;&amp; rflg[column + 1]) || (column == dep)]; } cout &lt;&lt; '\n'; } } void print_val(int dep, pair&lt;int, int&gt; square, vector&lt;int&gt; val) { auto [x, y] = square; for (int row = 1; row &lt;= x; row++) { for (int column = 1; column &lt; dep; column++) { for (int i = 1; i &lt; y; i++) cout &lt;&lt; ' '; cout &lt;&lt; " |"[(rflg[column] &amp;&amp; lflg[column + 1]) || (lflg[column] &amp;&amp; rflg[column + 1])]; } for (int i = 0; i &lt; y; i++) cout &lt;&lt; '-'; print_list(row, val[row - 1]); cout &lt;&lt; '\n'; } } void pt_tree(int cur, pair&lt;int, int&gt; square, int dep = 1) { if (cur == 0) return; lflg[dep] = 1; pt_tree(Tree[cur].son[1], square, dep + 1); if (Tree[cur].son[1]) print_branch(dep, square); rflg[dep] = 1; print_val(dep, square, {Tree[cur].val, Tree[cur].tag}); lflg[dep] = 0; if (Tree[cur].son[0]) print_branch(dep, square); pt_tree(Tree[cur].son[0], square, dep + 1); rflg[dep] = 0; } void push_down(int p) { if (Tree[p].tag) { Tree[Tree[p].son[0]].tag ^= 1; Tree[Tree[p].son[1]].tag ^= 1; Tree[p].tag = 0; swap(Tree[p].son[0], Tree[p].son[1]); } } void splay(int cur, int tar) { while (Tree[cur].par != tar) { push_down(cur); int cop = Tree[cur].par, cgp = Tree[cop].par; if (cgp != tar) if ((Tree[cgp].son[0] == cop) == (Tree[cop].son[0] == cur)) _rotate(cop); else _rotate(cur); _rotate(cur); } if (tar == 0) root = cur; } void insert(int x) { int cur = root, par = 0; while (cur) { push_down(cur); par = cur; cur = Tree[cur].son[x &gt; Tree[cur].val]; } id++; Tree[id].init(x, par); Tree[par].son[x &gt; Tree[par].val] = id; splay(id, 0); } int find(int sz) { int cur = root, par = 0; while (sz) { push_down(cur); par = cur; int t = Tree[Tree[cur].son[0]].sz + 1; if (sz == t) return cur; cur = Tree[cur].son[sz &gt; t]; if (sz &gt; t) sz -= t; } return 0; } void reverse(int l, int r) { l = find(l - 1); splay(l, 0); r = find(r + 1); splay(r, l); Tree[Tree[r].son[0]].tag ^= 1; splay(Tree[r].son[0], 0); pt_tree(root, {2, 6}); } void print(int cur) { if (cur == 0) return; push_down(cur); print(Tree[cur].son[0]); if (Tree[cur].val &gt; 0 &amp;&amp; Tree[cur].val &lt; 1e7) cout &lt;&lt; Tree[cur].val &lt;&lt; ' '; print(Tree[cur].son[1]); } int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; insert(-1e9); insert(1e9); for (int i = 1; i &lt;= n; i++) insert(i); while (m--) { int l, r; cin &gt;&gt; l &gt;&gt; r; reverse(l + 1, r + 1); } print(root); return 0; }]]></summary></entry><entry><title type="html">Splay 模板</title><link href="https://blog.ohtoai.fun/algorithm/acm_template/2022/08/08/Splay.html" rel="alternate" type="text/html" title="Splay 模板" /><published>2022-08-08T00:00:00+00:00</published><updated>2022-08-07T19:30:59+00:00</updated><id>https://blog.ohtoai.fun/algorithm/acm_template/2022/08/08/Splay</id><content type="html" xml:base="https://blog.ohtoai.fun/algorithm/acm_template/2022/08/08/Splay.html"><![CDATA[<h2 id="splay-数组实现模板">Splay 数组实现模板</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">son</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">sz</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

   <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">par</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">par</span><span class="p">;</span>
      <span class="n">sz</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span> <span class="n">Tree</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Splay</span>

<span class="kt">void</span> <span class="nf">update_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">sz</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">cnt</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">sz</span> <span class="o">+=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">sz</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">sz</span> <span class="o">+=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]].</span><span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">_rotate</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">p</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">p</span><span class="p">;</span>

   <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">;</span>

   <span class="n">Tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">d</span> <span class="o">^</span> <span class="mi">1</span><span class="p">];</span>
   <span class="n">Tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">d</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

   <span class="n">Tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">p</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
   <span class="n">Tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">d</span><span class="p">]].</span><span class="n">p</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

   <span class="n">update_size</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
   <span class="n">update_size</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">root</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
   <span class="k">else</span>
      <span class="n">Tree</span><span class="p">[</span><span class="n">z</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">z</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">splay</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tar</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">p</span> <span class="o">!=</span> <span class="n">tar</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">p</span><span class="p">,</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">p</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pp</span> <span class="o">!=</span> <span class="n">tar</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">((</span><span class="n">Tree</span><span class="p">[</span><span class="n">pp</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur</span><span class="p">))</span>
            <span class="n">_rotate</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
         <span class="k">else</span>
            <span class="n">_rotate</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">_rotate</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">tar</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">root</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// cerr &lt;&lt; "insert " &lt;&lt; v &lt;&lt; endl;</span>
   <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span> <span class="o">!=</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
      <span class="n">cur</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span><span class="p">];</span>
   <span class="p">}</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
      <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">sz</span><span class="o">++</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">cur</span> <span class="o">=</span> <span class="o">++</span><span class="n">id</span><span class="p">;</span>
      <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">init</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">pre</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pre</span><span class="p">)</span> <span class="n">Tree</span><span class="p">[</span><span class="n">pre</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">Tree</span><span class="p">[</span><span class="n">pre</span><span class="p">].</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="n">splay</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">find_pre</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">v</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">find_pre</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">);</span>
   <span class="k">else</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">find_pre</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">find_nxt</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">find_nxt</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">);</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">find_nxt</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// cerr &lt;&lt; "erase " &lt;&lt; v &lt;&lt; endl;</span>
   <span class="k">auto</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">find_pre</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
   <span class="n">splay</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="k">auto</span> <span class="n">nxt</span> <span class="o">=</span> <span class="n">find_nxt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
   <span class="n">splay</span><span class="p">(</span><span class="n">nxt</span><span class="p">,</span> <span class="n">pre</span><span class="p">);</span>

   <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">nxt</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Tree</span><span class="p">[</span><span class="n">nxt</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">splay</span><span class="p">(</span><span class="n">nxt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
   <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">sz</span><span class="o">--</span><span class="p">;</span>
   <span class="n">splay</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">querry_val</span><span class="p">(</span><span class="kt">int</span> <span class="n">rk</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

   <span class="k">while</span> <span class="p">(</span><span class="n">rk</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">Lsize</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">sz</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Lsize</span> <span class="o">&gt;=</span> <span class="n">rk</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">now</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Lsize</span> <span class="o">+</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">rk</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">splay</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
         <span class="k">return</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="n">rk</span> <span class="o">-=</span> <span class="n">Lsize</span> <span class="o">+</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">cnt</span><span class="p">;</span>
         <span class="n">now</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">querry_rank</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

   <span class="k">while</span> <span class="p">(</span><span class="n">now</span> <span class="o">&amp;&amp;</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">val</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">Lsize</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">sz</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">pre</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">now</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="n">tot</span> <span class="o">+=</span> <span class="n">Lsize</span> <span class="o">+</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">cnt</span><span class="p">;</span>
         <span class="n">now</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&amp;&amp;</span> <span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="n">tot</span> <span class="o">+=</span> <span class="n">Tree</span><span class="p">[</span><span class="n">Tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">sz</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="p">)</span>
      <span class="n">splay</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pre</span><span class="p">)</span>
      <span class="n">splay</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">tot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nxt</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mf">1e9</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="n">nxt</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">);</span>
   <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="mf">1e9</span><span class="p">)</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
   <span class="n">splay</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pre</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mf">1e9</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="n">pre</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">);</span>
   <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">pre</span><span class="p">(</span><span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">son</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="o">-</span><span class="mf">1e9</span><span class="p">)</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
   <span class="n">splay</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">Tree</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="c1">// freopen("b.txt", "r", stdin);</span>
   <span class="c1">// freopen("c.txt", "w", stdout);</span>
   <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>

   <span class="c1">// ! 一定要哨兵</span>

   <span class="n">insert</span><span class="p">(</span><span class="mf">1e9</span><span class="p">);</span>
   <span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mf">1e9</span><span class="p">);</span>

   <span class="k">while</span> <span class="p">(</span><span class="n">t</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
      <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">op</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="n">erase</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">querry_rank</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">querry_val</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pre</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nxt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>phrk</name><email>phrknfish@outlook.com</email></author><category term="algorithm" /><category term="ACM_template" /><category term="Splay" /><summary type="html"><![CDATA[Splay 数组实现模板 #include &lt;iostream&gt; using namespace std; const int N = 1e5 + 10; struct Node { int son[2], p; int sz, cnt; int val; void init(int v, int par) { val = v, p = par; sz = 1; cnt = 1; son[0] = son[1] = 0; } } Tree[N]; int root = 0; // Splay void update_size(int p) { Tree[p].sz = Tree[p].cnt; if (Tree[p].son[0]) Tree[p].sz += Tree[Tree[p].son[0]].sz; if (Tree[p].son[1]) Tree[p].sz += Tree[Tree[p].son[1]].sz; } void _rotate(int x) { int y = Tree[x].p; int z = Tree[y].p; int d = Tree[y].son[1] == x; Tree[y].son[d] = Tree[x].son[d ^ 1]; Tree[x].son[d ^ 1] = y; Tree[x].p = z; Tree[y].p = x; if (Tree[y].son[d]) Tree[Tree[y].son[d]].p = y; update_size(y); update_size(x); if (z == 0) root = x; else Tree[z].son[Tree[z].son[1] == y] = x; } int id = 0; void splay(int cur, int tar) { while (Tree[cur].p != tar) { int p = Tree[cur].p, pp = Tree[p].p; if (pp != tar) { if ((Tree[pp].son[1] == p) == (Tree[p].son[1] == cur)) _rotate(p); else _rotate(cur); } _rotate(cur); } if (tar == 0) root = cur; } void insert(int v) { // cerr &lt;&lt; "insert " &lt;&lt; v &lt;&lt; endl; int cur = root; int pre = 0; while (cur &amp;&amp; Tree[cur].val != v) { pre = cur; cur = Tree[cur].son[v &gt; Tree[cur].val]; } if (cur) { Tree[cur].cnt++; Tree[cur].sz++; } else { cur = ++id; Tree[cur].init(v, pre); if (pre) Tree[pre].son[v &gt; Tree[pre].val] = cur; } splay(cur, 0); } int find_pre(int cur, int v) { if (cur == 0) return 0; if (Tree[cur].val &gt;= v) return find_pre(Tree[cur].son[0], v); else { auto t = find_pre(Tree[cur].son[1], v); if (t) return t; return cur; } return 0; } int find_nxt(int cur, int v) { if (cur == 0) return 0; if (Tree[cur].val &lt;= v) { return find_nxt(Tree[cur].son[1], v); } else { auto t = find_nxt(Tree[cur].son[0], v); if (t) return t; return cur; } } void erase(int v) { // cerr &lt;&lt; "erase " &lt;&lt; v &lt;&lt; endl; auto pre = find_pre(root, v); splay(pre, 0); auto nxt = find_nxt(root, v); splay(nxt, pre); int cur = Tree[nxt].son[0]; if (cur == 0 || Tree[cur].cnt == 1) { Tree[nxt].son[0] = 0; splay(nxt, 0); return; } Tree[cur].cnt--; Tree[cur].sz--; splay(cur, 0); } int querry_val(int rk) { int now = root; while (rk) { int Lsize = Tree[now].son[0] ? Tree[Tree[now].son[0]].sz : 0; if (Lsize &gt;= rk) { now = Tree[now].son[0]; } else if (Lsize + Tree[now].cnt &gt;= rk) { splay(now, 0); return Tree[now].val; } else { rk -= Lsize + Tree[now].cnt; now = Tree[now].son[1]; } } return 0; } int querry_rank(int x) { int now = root; int pre = 0; int tot = 0; while (now &amp;&amp; Tree[now].val != x) { int Lsize = Tree[now].son[0] ? Tree[Tree[now].son[0]].sz : 0; pre = now; if (Tree[now].val &gt; x) { now = Tree[now].son[0]; } else { tot += Lsize + Tree[now].cnt; now = Tree[now].son[1]; } } if (now &amp;&amp; Tree[now].son[0]) tot += Tree[Tree[now].son[0]].sz; if (now) splay(now, 0); else if (pre) splay(pre, 0); return tot + 1; } int nxt(int cur, int x) { if (cur == 0) return 1e9; if (Tree[cur].val &lt;= x) return nxt(Tree[cur].son[1], x); auto t = nxt(Tree[cur].son[0], x); if (t != 1e9) return t; splay(cur, 0); return Tree[cur].val; } int pre(int cur, int x) { if (cur == 0) return -1e9; if (Tree[cur].val &gt;= x) return pre(Tree[cur].son[0], x); auto t = pre(Tree[cur].son[1], x); if (t != -1e9) return t; splay(cur, 0); return Tree[cur].val; } int main() { // freopen("b.txt", "r", stdin); // freopen("c.txt", "w", stdout); cin.tie(0)-&gt;sync_with_stdio(false); int t; cin &gt;&gt; t; // ! 一定要哨兵 insert(1e9); insert(-1e9); while (t--) { int op, x; cin &gt;&gt; op &gt;&gt; x; if (op == 1) insert(x); if (op == 2) erase(x); if (op == 3) cout &lt;&lt; querry_rank(x) - 1 &lt;&lt; '\n'; if (op == 4) cout &lt;&lt; querry_val(x + 1) &lt;&lt; '\n'; if (op == 5) cout &lt;&lt; pre(root, x) &lt;&lt; '\n'; if (op == 6) cout &lt;&lt; nxt(root, x) &lt;&lt; '\n'; } return 0; }]]></summary></entry></feed>